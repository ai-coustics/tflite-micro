diff --git a/algo/kernels/activations/hifi4/xa_nn_activations_sym16_sym16.c b/algo/kernels/activations/hifi4/xa_nn_activations_sym16_sym16.c
index 740a78c..5219884 100644
--- a/algo/kernels/activations/hifi4/xa_nn_activations_sym16_sym16.c
+++ b/algo/kernels/activations/hifi4/xa_nn_activations_sym16_sym16.c
@@ -52,13 +52,11 @@ static const uint16_t sigmoid_table_uint16[256] = {
     65533, 65533, 65533, 65534, 65534, 65534, 65534, 65534, 65534, 65534, 65534,
     65534, 65534, 65535};
 
-#if !(XCHAL_HAVE_HIFI1 && (XCHAL_HW_VERSION >= RI9_HWVERSION))
 static inline UWORD32 abs(WORD32 input)
 {
   return ((UWORD32)((-1)*input));
 }
 #endif
-#endif//XCHAL_HAVE_HIFI1 && (XCHAL_HW_VERSION >= RI9_HWVERSION)
 
 static void internal_vec_sigmoid_sym16s_sym16s_spc(WORD16 *p_out,
                                                    const WORD16 *p_vec,
@@ -89,10 +87,6 @@ static void internal_vec_sigmoid_sym16s_sym16s_spc(WORD16 *p_out,
   ae_int16x4 inp_mult = input_multiplier;
 #else
   ae_int16x4 sign_bit_mask = AE_MOVDA16(0x7FFF);
-  int sar_reg_val = AE_MOVASAR();
-  int sar_reg_low_half = sar_reg_val & 0x7F;
-  sar_reg_val = sar_reg_val >> 7;
-  int sar_reg_up_half = sar_reg_val & 0x7F;
   WUR_AE_SAR(4);
 #endif  
 
@@ -183,82 +177,7 @@ static void internal_vec_sigmoid_sym16s_sym16s_spc(WORD16 *p_out,
 #endif
     AE_SA16X4_IP(out, out_align, (ae_int16x4 *)out_ptr); 
   }
-#if XCHAL_HAVE_HIFI1 && (XCHAL_HW_VERSION >= RI9_HWVERSION)
-  if((vec_length & 3) != 0){
-    AE_LAV16X4_XP(inp0, inp_align, (ae_int16x4 *)in_ptr_align, ((vec_length & 3) << 1));
-    AE_MUL16X4(inp_x_inp_mul0, inp_x_inp_mul1, inp0, inp_mult);
-    abs_inp_x_inp_mul0 = AE_ABS32S(inp_x_inp_mul0);
-    abs_inp_x_inp_mul1 = AE_ABS32S(inp_x_inp_mul1);
-
-    abs_inp_x_inp_mul0 = AE_ABS32S(inp_x_inp_mul0);
-    abs_inp_x_inp_mul1 = AE_ABS32S(inp_x_inp_mul1);
-
-    ut = AE_SEL16_6420(AE_MOVINT16X4_FROMINT32X2(abs_inp_x_inp_mul0), AE_MOVINT16X4_FROMINT32X2(abs_inp_x_inp_mul1));
-    ut = AE_AND16(ut, mask_nine_bit);
-
-    uh_0 = AE_SRAI32(abs_inp_x_inp_mul0, 9);
-    uh_1 = AE_SRAI32(abs_inp_x_inp_mul1, 9);
-
-    int id0,id1,id2,id3;
-    id0 = AE_MOVAD32_H(AE_SLAI32(uh_0, 1));
-    id1 = AE_MOVAD32_L(AE_SLAI32(uh_0, 1));
-    id2 = AE_MOVAD32_H(AE_SLAI32(uh_1, 1));
-    id3 = AE_MOVAD32_L(AE_SLAI32(uh_1, 1));
-
-    ae_int16 *psigmoid_table_uint16 = (ae_int16 *)sigmoid_table_uint16;
-
-    ae_int16x4 zero_16x4 = AE_ZERO16();
-
-    ae_int16x4 sel0 = AE_SEL16_7610(AE_L16_X((ae_int16 *)psigmoid_table_uint16, id1), zero_16x4); 
-    ua0 = AE_MOVINT32X2_FROMINT16X4(AE_SEL16_5146(sel0, AE_L16_X((ae_int16 *)psigmoid_table_uint16, id0)));
- 
-    sel0 = AE_SEL16_7610(AE_L16_X((ae_int16 *)psigmoid_table_uint16, id3), zero_16x4);
-    ua1  = AE_MOVINT32X2_FROMINT16X4(AE_SEL16_5146(sel0, AE_L16_X((ae_int16 *)psigmoid_table_uint16, id2)));
-
-    psigmoid_table_uint16++;
-
-    sel0 = AE_SEL16_7610(AE_L16_X((ae_int16 *)psigmoid_table_uint16, id1), zero_16x4);
-    ub0  = AE_MOVINT32X2_FROMINT16X4(AE_SEL16_5146(sel0, AE_L16_X((ae_int16 *)psigmoid_table_uint16, id0)));
-
-    sel0 = AE_SEL16_7610(AE_L16_X((ae_int16 *)psigmoid_table_uint16, id3), zero_16x4);
-    ub1 = AE_MOVINT32X2_FROMINT16X4(AE_SEL16_5146(sel0, AE_L16_X((ae_int16 *)psigmoid_table_uint16, id2)));
-
-    ua_lsh0 = AE_SLAI32S(ua0, 9);
-    ua_lsh1 = AE_SLAI32S(ua1, 9);
-
-    ub_minus_ua0 = AE_SUB32S(ub0, ua0);
-    ub_minus_ua1 = AE_SUB32S(ub1, ua1);
-
-    res0 = ua_lsh0;
-    res1 = ua_lsh1;
-
-    AE_MULAP32X16X2_H(res0, ub_minus_ua0, ut);
-    AE_MULAP32X16X2_L(res1, ub_minus_ua1, ut);
-  
-    x0 = AE_LT32(uh_0, uint8_max);
-    x1 = AE_LT32(uh_1, uint8_max);
-    AE_MOVF32X2(res0, res_sat_val, x0); 
-    AE_MOVF32X2(res1, res_sat_val, x1); 
-
-    res0_plus = AE_ADD32S(res0, add_val);
-    res1_plus = AE_ADD32S(res1, add_val);
 
-    res0 = AE_SUB32S(sub_val, res0);
-    res1 = AE_SUB32S(sub_val, res1);
- 
-    x0 = AE_LT32(inp_x_inp_mul0, AE_ZERO32());
-    x1 = AE_LT32(inp_x_inp_mul1, AE_ZERO32());
-
-    AE_MOVF32X2(res0, res0_plus, x0);
-    AE_MOVF32X2(res1, res1_plus, x1);
-
-    res0 = AE_SRAI32(res0, 10);
-    res1 = AE_SRAI32(res1, 10);
-    ae_int16x4 out = AE_SAT16X4(res0, res1);
-    AE_SAV16X4_XP(out, out_align, (ae_int16x4 *)out_ptr, ((vec_length & 3) << 1));  
-  }
-  AE_SA64POS_FP(out_align, out_ptr);
-#else //XCHAL_HAVE_HIFI1 && (XCHAL_HW_VERSION >= RI9_HWVERSION)
   AE_SA64POS_FP(out_align, out_ptr);
   p_vec = (WORD16 *)in_ptr_align;
   p_out = (WORD16 *)out_ptr;
@@ -271,7 +190,6 @@ static void internal_vec_sigmoid_sym16s_sym16s_spc(WORD16 *p_out,
     out = AE_AND16(out, sign_bit_mask);    
     AE_S16_0_IP(out, (ae_int16 *)p_out, sizeof(WORD16));  
   }
-  AE_MOVSARA7X2(sar_reg_up_half, sar_reg_low_half);
 #else
   /* Following code is directly adapted from TFLM ref code */
   for (i = 0; i < (vec_length & 3); ++i, p_vec++, p_out++) {
@@ -294,7 +212,6 @@ static void internal_vec_sigmoid_sym16s_sym16s_spc(WORD16 *p_out,
     *p_out =(WORD16)result;
   }
 #endif
-#endif//XCHAL_HAVE_HIFI1 && (XCHAL_HW_VERSION >= RI9_HWVERSION)
 }
 
 /* The scale of input for TFLM reference is 4096*3, which is maintained in the LUT based implementation 
@@ -356,10 +273,6 @@ WORD32 xa_nn_vec_sigmoid_sym16s_sym16s(WORD16 *p_out,
 #else
   ae_int16x4 sign_bit_mask = AE_MOVDA16(0x7FFF);
   ae_int16x4 sigmoid_in;
-  int sar_reg_val = AE_MOVASAR();
-  int sar_reg_low_half = sar_reg_val & 0x7F;
-  sar_reg_val = sar_reg_val >> 7;
-  int sar_reg_up_half = sar_reg_val & 0x7F;
   WUR_AE_SAR(4);
 #endif
   int i;
@@ -459,87 +372,6 @@ WORD32 xa_nn_vec_sigmoid_sym16s_sym16s(WORD16 *p_out,
     AE_SA16X4_IP(out, out_align, (ae_int16x4 *)out_ptr); 
   }
 
-#if XCHAL_HAVE_HIFI1 && (XCHAL_HW_VERSION >= RI9_HWVERSION)
-  if((vec_length & 3) != 0){
-    AE_LAV16X4_XP(inp0, inp_align, (ae_int16x4 *)in_ptr_align, ((vec_length & 3) << 1));
-    inp_x_inp_mul0 = round;
-    inp_x_inp_mul1 = round;
-
-    AE_MULA16X4(inp_x_inp_mul0, inp_x_inp_mul1, inp0, inp_mult);
-
-    inp_x_inp_mul0 = AE_SRAA32(inp_x_inp_mul0, input_left_shift);
-    inp_x_inp_mul1 = AE_SRAA32(inp_x_inp_mul1, input_left_shift);
-
-    abs_inp_x_inp_mul0 = AE_ABS32S(inp_x_inp_mul0);
-    abs_inp_x_inp_mul1 = AE_ABS32S(inp_x_inp_mul1);
-
-    ut = AE_SEL16_6420(AE_MOVINT16X4_FROMINT32X2(abs_inp_x_inp_mul0), AE_MOVINT16X4_FROMINT32X2(abs_inp_x_inp_mul1));
-    ut = AE_AND16(ut, mask_nine_bit);
-
-    uh_0 = AE_SRAI32(abs_inp_x_inp_mul0, 9);
-    uh_1 = AE_SRAI32(abs_inp_x_inp_mul1, 9);
-
-    int id0,id1,id2,id3;
-    id0 = AE_MOVAD32_H(AE_SLAI32(uh_0, 1));
-    id1 = AE_MOVAD32_L(AE_SLAI32(uh_0, 1));
-    id2 = AE_MOVAD32_H(AE_SLAI32(uh_1, 1));
-    id3 = AE_MOVAD32_L(AE_SLAI32(uh_1, 1));
-
-    ae_int16 *psigmoid_table_uint16 = (ae_int16 *)sigmoid_table_uint16;
-
-    ae_int16x4 zero_16x4 = AE_ZERO16();
-
-    ae_int16x4 sel0 = AE_SEL16_7610(AE_L16_X((ae_int16 *)psigmoid_table_uint16, id1), zero_16x4); 
-    ua0 = AE_MOVINT32X2_FROMINT16X4(AE_SEL16_5146(sel0, AE_L16_X((ae_int16 *)psigmoid_table_uint16, id0)));
- 
-    sel0 = AE_SEL16_7610(AE_L16_X((ae_int16 *)psigmoid_table_uint16, id3), zero_16x4);
-    ua1  = AE_MOVINT32X2_FROMINT16X4(AE_SEL16_5146(sel0, AE_L16_X((ae_int16 *)psigmoid_table_uint16, id2)));
-
-    psigmoid_table_uint16++;
-
-    sel0 = AE_SEL16_7610(AE_L16_X((ae_int16 *)psigmoid_table_uint16, id1), zero_16x4);
-    ub0  = AE_MOVINT32X2_FROMINT16X4(AE_SEL16_5146(sel0, AE_L16_X((ae_int16 *)psigmoid_table_uint16, id0)));
-
-    sel0 = AE_SEL16_7610(AE_L16_X((ae_int16 *)psigmoid_table_uint16, id3), zero_16x4);
-    ub1 = AE_MOVINT32X2_FROMINT16X4(AE_SEL16_5146(sel0, AE_L16_X((ae_int16 *)psigmoid_table_uint16, id2)));
-
-    ua_lsh0 = AE_SLAI32S(ua0, 9);
-    ua_lsh1 = AE_SLAI32S(ua1, 9);
-
-    ub_minus_ua0 = AE_SUB32S(ub0, ua0);
-    ub_minus_ua1 = AE_SUB32S(ub1, ua1);
-
-    res0 = ua_lsh0;
-    res1 = ua_lsh1;
-
-    AE_MULAP32X16X2_H(res0, ub_minus_ua0, ut);
-    AE_MULAP32X16X2_L(res1, ub_minus_ua1, ut);
-  
-    x0 = AE_LT32(uh_0, uint8_max);
-    x1 = AE_LT32(uh_1, uint8_max);
-    AE_MOVF32X2(res0, res_sat_val, x0); 
-    AE_MOVF32X2(res1, res_sat_val, x1); 
-
-    res0_plus = AE_ADD32S(res0, add_val);
-    res1_plus = AE_ADD32S(res1, add_val);
-
-    res0 = AE_SUB32S(sub_val, res0);
-    res1 = AE_SUB32S(sub_val, res1);
- 
-    x0 = AE_LT32(inp_x_inp_mul0, AE_ZERO32());
-    x1 = AE_LT32(inp_x_inp_mul1, AE_ZERO32());
-
-    AE_MOVF32X2(res0, res0_plus, x0);
-    AE_MOVF32X2(res1, res1_plus, x1);
-
-    res0 = AE_SRAI32(res0, 10);
-    res1 = AE_SRAI32(res1, 10);
-    ae_int16x4 out = AE_SAT16X4(res0, res1);
-    AE_SAV16X4_XP(out, out_align, (ae_int16x4 *)out_ptr, ((vec_length & 3) << 1));  
-  }
-  AE_SA64POS_FP(out_align, out_ptr);
-#else //XCHAL_HAVE_HIFI1 && (XCHAL_HW_VERSION >= RI9_HWVERSION)
-
   AE_SA64POS_FP(out_align, out_ptr);
   p_vec = (WORD16 *)in_ptr_align;
   p_out = (WORD16 *)out_ptr;
@@ -558,7 +390,6 @@ WORD32 xa_nn_vec_sigmoid_sym16s_sym16s(WORD16 *p_out,
     out = AE_AND16(out, sign_bit_mask);    
     AE_S16_0_IP(out, (ae_int16 *)p_out, sizeof(WORD16));  
   }
-  AE_MOVSARA7X2(sar_reg_up_half, sar_reg_low_half);
 #else
   /* Following code is directly adapted from TFLM ref code */
   for (i = 0; i < (vec_length & 3); ++i, p_vec++, p_out++) {
@@ -584,7 +415,6 @@ WORD32 xa_nn_vec_sigmoid_sym16s_sym16s(WORD16 *p_out,
     *p_out =(WORD16)result;
   }
 #endif
-#endif  //XCHAL_HAVE_HIFI1 && (XCHAL_HW_VERSION >= RI9_HWVERSION)
   return 0;
 }
 
@@ -645,10 +475,6 @@ WORD32 xa_nn_vec_tanh_sym16s_sym16s(WORD16 *p_out,
   ae_int16x4 ut;
 #else
   ae_int16x4 tanh_in;
-  int sar_reg_val = AE_MOVASAR();
-  int sar_reg_low_half = sar_reg_val & 0x7F;
-  sar_reg_val = sar_reg_val >> 7;
-  int sar_reg_up_half = sar_reg_val & 0x7F;
   WUR_AE_SAR(4);
 #endif
 
@@ -744,87 +570,6 @@ WORD32 xa_nn_vec_tanh_sym16s_sym16s(WORD16 *p_out,
 #endif
     AE_SA16X4_IP(out, out_align, (ae_int16x4 *)out_ptr);
   }
-#if XCHAL_HAVE_HIFI1 && (XCHAL_HW_VERSION >= RI9_HWVERSION)
-  if((vec_length & 3) != 0){
-    AE_LAV16X4_XP(inp0, inp_align, in_ptr_align, ((vec_length & 3) << 1));
-    inp_x_inp_mul0 = round;
-    inp_x_inp_mul1 = round;
-
-    AE_MULA16X4(inp_x_inp_mul0, inp_x_inp_mul1, inp0, inp_mult);
-
-    inp_x_inp_mul0 = AE_SRAA32(inp_x_inp_mul0, input_left_shift);
-    inp_x_inp_mul1 = AE_SRAA32(inp_x_inp_mul1, input_left_shift);
-
-    abs_inp_x_inp_mul0 = AE_ABS32S(inp_x_inp_mul0);
-    abs_inp_x_inp_mul1 = AE_ABS32S(inp_x_inp_mul1);
-
-    ut = AE_SEL16_6420(AE_MOVINT16X4_FROMINT32X2(abs_inp_x_inp_mul0), AE_MOVINT16X4_FROMINT32X2(abs_inp_x_inp_mul1));
-    ut = AE_AND16(ut, mask_eight_bit);
-
-    uh_0 = AE_SRAI32(abs_inp_x_inp_mul0, 8);
-    uh_1 = AE_SRAI32(abs_inp_x_inp_mul1, 8);
-
-    int id0,id1,id2,id3;
-    id0 = AE_MOVAD32_H(AE_SLAI32(uh_0, 1));
-    id1 = AE_MOVAD32_L(AE_SLAI32(uh_0, 1));
-    id2 = AE_MOVAD32_H(AE_SLAI32(uh_1, 1));
-    id3 = AE_MOVAD32_L(AE_SLAI32(uh_1, 1));
-
-    ae_int16 *psigmoid_table_uint16 = (ae_int16 *)sigmoid_table_uint16;
-    ae_int16x4 zero_16x4 = AE_ZERO16();
-
-    ae_int16x4 sel0 = AE_SEL16_7610(AE_L16_X((ae_int16 *)psigmoid_table_uint16, id1), zero_16x4); 
-    ua0 = AE_MOVINT32X2_FROMINT16X4(AE_SEL16_5146(sel0, AE_L16_X((ae_int16 *)psigmoid_table_uint16, id0)));
- 
-    sel0 = AE_SEL16_7610(AE_L16_X((ae_int16 *)psigmoid_table_uint16, id3), zero_16x4);
-    ua1  = AE_MOVINT32X2_FROMINT16X4(AE_SEL16_5146(sel0, AE_L16_X((ae_int16 *)psigmoid_table_uint16, id2)));
-
-    psigmoid_table_uint16++;
-
-    sel0 = AE_SEL16_7610(AE_L16_X((ae_int16 *)psigmoid_table_uint16, id1), zero_16x4);
-    ub0  = AE_MOVINT32X2_FROMINT16X4(AE_SEL16_5146(sel0, AE_L16_X((ae_int16 *)psigmoid_table_uint16, id0)));
-
-    sel0 = AE_SEL16_7610(AE_L16_X((ae_int16 *)psigmoid_table_uint16, id3), zero_16x4);
-    ub1 = AE_MOVINT32X2_FROMINT16X4(AE_SEL16_5146(sel0, AE_L16_X((ae_int16 *)psigmoid_table_uint16, id2)));
-
-    ua_lsh0 = AE_SLAI32S(ua0, 8);
-    ua_lsh1 = AE_SLAI32S(ua1, 8);
-
-    ub_minus_ua0 = AE_SUB32S(ub0, ua0);
-    ub_minus_ua1 = AE_SUB32S(ub1, ua1);
-
-    res0 = ua_lsh0;
-    res1 = ua_lsh1;
-
-    AE_MULAP32X16X2_H(res0, ub_minus_ua0, ut);
-    AE_MULAP32X16X2_L(res1, ub_minus_ua1, ut);
-
-    x0 = AE_LT32(uh_0, uint8_max);
-    x1 = AE_LT32(uh_1, uint8_max);
-
-    AE_MOVF32X2(res0, res_sat_val, x0); 
-    AE_MOVF32X2(res1, res_sat_val, x1); 
-
-    res0_minus = AE_SUB32S(res0, sub_val0);
-    res1_minus = AE_SUB32S(res1, sub_val0);
-
-    res0 = AE_SUB32S(sub_val1, res0);
-    res1 = AE_SUB32S(sub_val1, res1);
-
-    x0 = AE_LT32(inp_x_inp_mul0, AE_ZERO32());
-    x1 = AE_LT32(inp_x_inp_mul1, AE_ZERO32());
-
-    AE_MOVF32X2(res0, res0_minus, x0);
-    AE_MOVF32X2(res1, res1_minus, x1);
-
-    res0 = AE_SRAI32(res0, 8);
-    res1 = AE_SRAI32(res1, 8);
-    ae_int16x4 out = AE_SAT16X4(res0, res1);
-
-    AE_SAV16X4_XP(out, out_align, (ae_int16x4 *)out_ptr, ((vec_length & 3) << 1));  
-  }
-  AE_SA64POS_FP(out_align, out_ptr);
-#else //XCHAL_HAVE_HIFI1 && (XCHAL_HW_VERSION >= RI9_HWVERSION)
 
   AE_SA64POS_FP(out_align, out_ptr);
   p_vec = (WORD16 *)in_ptr_align;
@@ -842,7 +587,6 @@ WORD32 xa_nn_vec_tanh_sym16s_sym16s(WORD16 *p_out,
     ae_int16x4 out = AE_TANH16X4(tanh_in);   
     AE_S16_0_IP(out, (ae_int16 *)p_out, sizeof(WORD16));  
   }
-  AE_MOVSARA7X2(sar_reg_up_half, sar_reg_low_half);
 #else
   /* Following code is directly adapted from TFLM ref code */
   for (i = 0; i < (vec_length & 3); ++i, p_vec++, p_out++) {
@@ -873,6 +617,5 @@ WORD32 xa_nn_vec_tanh_sym16s_sym16s(WORD16 *p_out,
     *p_out = (WORD16)result;
   }
 #endif
-#endif//XCHAL_HAVE_HIFI1 && (XCHAL_HW_VERSION >= RI9_HWVERSION)
   return 0;
 }
diff --git a/algo/kernels/basic/hifi4/xa_nn_elm_squared_diff_quant16.c b/algo/kernels/basic/hifi4/xa_nn_elm_squared_diff_quant16.c
new file mode 100644
index 0000000..136177f
--- /dev/null
+++ b/algo/kernels/basic/hifi4/xa_nn_elm_squared_diff_quant16.c
@@ -0,0 +1,635 @@
+/*******************************************************************************
+* Copyright (c) 2018-2023 Cadence Design Systems, Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining
+* a copy of this software and associated documentation files (the
+* "Software"), to use this Software with Cadence processor cores only and
+* not with any other processors and platforms, subject to
+* the following conditions:
+*
+* The above copyright notice and this permission notice shall be included
+* in all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************************/
+#include "xa_nnlib_common.h"
+#include "xa_nn_basic_state.h"
+#include "xa_nnlib_kernels_api.h"
+#include "xa_nnlib_common_macros.h"
+
+#if XCHAL_HAVE_HIFI1
+
+#define MAX_16X4(id1, id0) \
+        id1 = AE_MAX16(id1, id0);
+#define MIN_16X4(id1, id0) \
+        id1 = AE_MIN16(id1, id0);
+#define LIMIT16X4(out, inp, min, max){\
+        out = min;\
+        MAX_16X4(out, inp);\
+        MIN_16X4(out, max);\
+}
+
+#else
+
+#define MAX_16X4(id1, id0) { \
+        xtbool4 bool4 = AE_LT16(id1, id0); \
+        AE_MOVT16X4(id1, id0, bool4);\
+}
+#define MIN_16X4(id1, id0) { \
+        xtbool4 bool4 = AE_LT16(id1, id0); \
+        AE_MOVF16X4(id1, id0, bool4);\
+}
+#define LIMIT16X4(out, inp, min, max){\
+        out = min;\
+        MAX_16X4(out, inp);\
+        MIN_16X4(out, max);\
+}
+#endif
+
+#define MULTIPLYBYQUANTIZEDMULTIPLIER_RIGHT(out, inp1, multiplier, right_shift) \
+{\
+  inp1 = AE_MULFP32X2RAS(inp1, ((multiplier))); \
+  out = AE_MULFP32X2RS(inp1, right_shift); \
+}
+
+static void internal_elm_squared_diff_broadcast_2D_sym16sxsym16s_sym16s(WORD16 * __restrict__ p_out,
+                            WORD32  out_left_shift,
+                            WORD32  out_multiplier,
+                            WORD32  out_activation_min,
+                            WORD32  out_activation_max,
+                    const   WORD16 * __restrict__ p_inp1,
+                            WORD32  inp1_left_shift,
+                            WORD32  inp1_multiplier,
+                    const   WORD16 * __restrict__ p_inp2,
+                            WORD32  inp2_left_shift,
+                            WORD32  inp2_multiplier,
+                            WORD32  left_shift,
+                            WORD32  out_lc,
+                            WORD32  in_lc)
+{
+  int i, j;
+  WORD16 * __restrict__ p_a = (WORD16 *)p_inp1;
+  WORD16 * __restrict__ p_b = (WORD16 *)p_inp2;
+  WORD16 *__restrict__ p_c;
+
+#if TFLITE_SINGLE_ROUNDING
+  WORD32 out_ls, out_rs;
+  out_ls = out_left_shift;
+  out_rs = out_left_shift;
+  (void)out_rs;
+#else
+  WORD32 out_ls, out_rs;
+  out_ls = out_left_shift > 0 ? out_left_shift : 0;
+  out_rs = out_left_shift < 0 ? -out_left_shift : 0;
+#endif
+
+//  const ae_int32x2 za = AE_MOVDA32(-inp1_zero_bias);
+//  const ae_int32x2 zb = AE_MOVDA32(-inp2_zero_bias);
+
+  /* intermediate results and scratch registers */
+  ae_int16x4 a0_3, a4_7, b0_3, b4_7;
+
+  ae_int32x2 shifted_a0_1, shifted_a2_3, shifted_a4_5, shifted_a6_7;
+  ae_int32x2 shifted_b0_1, shifted_b2_3, shifted_b4_5, shifted_b6_7;
+
+  ae_int32x2 raw_diff0_1, raw_diff2_3, raw_diff4_5, raw_diff6_7;
+
+//  ae_int16x4 out0, out1;
+//  ae_int16x4 out2, out3;
+
+  int num_simd8_ops;
+  int num_scalar_ops;
+
+  if(out_lc == 1)
+  {
+    num_simd8_ops = in_lc >> 3;
+    num_scalar_ops = in_lc & 7;
+  }
+  else
+  {
+    num_simd8_ops = (in_lc >> 4) << 1;
+    num_scalar_ops = in_lc & 15;
+  }
+
+  for(i = 0; i < out_lc; i++)
+  {
+    p_a = (WORD16 *)&p_inp1[i * in_lc];
+    p_b = (WORD16 *)p_inp2;
+    p_c = (WORD16 *)&p_out[i * in_lc];
+
+    ae_valign va_a, va_b, va_c = AE_ZALIGN64();
+    va_a = AE_LA64_PP(p_a);
+    va_b = AE_LA64_PP(p_b);
+
+    for(j = 0; j < num_simd8_ops; j++)
+    {
+      ae_int32x2 out0_32, out1_32, out2_32, out3_32;
+      AE_LA16X4_IP(a0_3, va_a, (ae_int16x4 *)p_a);
+      AE_LA16X4_IP(a4_7, va_a, (ae_int16x4 *)p_a);
+      AE_LA16X4_IP(b0_3, va_b, (ae_int16x4 *)p_b);
+      AE_LA16X4_IP(b4_7, va_b, (ae_int16x4 *)p_b);
+
+      /* LSH (and promote to 32-bit)*/
+      AE_MUL16X4(shifted_a0_1, shifted_a2_3, a0_3, AE_MOVDA16(1));
+//      shifted_a0_1 = AE_SUB32(shifted_a0_1, za);
+//      shifted_a2_3 = AE_SUB32(shifted_a2_3, za);
+      shifted_a0_1 = AE_SLAA32S(shifted_a0_1, left_shift);
+      shifted_a2_3 = AE_SLAA32S(shifted_a2_3, left_shift);
+
+      AE_MUL16X4(shifted_a4_5, shifted_a6_7, a4_7, AE_MOVDA16(1));
+//      shifted_a4_5 = AE_SUB32(shifted_a4_5, za);
+//      shifted_a6_7 = AE_SUB32(shifted_a6_7, za);
+      shifted_a4_5 = AE_SLAA32S(shifted_a4_5, left_shift);
+      shifted_a6_7 = AE_SLAA32S(shifted_a6_7, left_shift);
+
+      AE_MUL16X4(shifted_b0_1, shifted_b2_3, b0_3, AE_MOVDA16(1));
+//      shifted_b0_1 = AE_SUB32(shifted_b0_1, zb);
+//      shifted_b2_3 = AE_SUB32(shifted_b2_3, zb);
+      shifted_b0_1 = AE_SLAA32S(shifted_b0_1, left_shift);
+      shifted_b2_3 = AE_SLAA32S(shifted_b2_3, left_shift);
+
+      AE_MUL16X4(shifted_b4_5, shifted_b6_7, b4_7, AE_MOVDA16(1));
+//      shifted_b4_5 = AE_SUB32(shifted_b4_5, zb);
+//      shifted_b6_7 = AE_SUB32(shifted_b6_7, zb);
+      shifted_b4_5 = AE_SLAA32S(shifted_b4_5, left_shift);
+      shifted_b6_7 = AE_SLAA32S(shifted_b6_7, left_shift);
+
+#if 0
+      raw_sum0_1 = raw_sum2_3 = raw_sum4_5 = raw_sum6_7 = AE_ZERO32();
+      // Scaled input
+      MPY_BY_QUANT_MACC_ST_ONE_EXP_X2X2_OUT32(raw_sum0_1, raw_sum2_3, shifted_a0_1, shifted_a2_3, inp1_multiplier, inp1_left_shift);
+      MPY_BY_QUANT_MACC_ST_ONE_EXP_X2X2_OUT32(raw_sum0_1, raw_sum2_3, shifted_b0_1, shifted_b2_3, inp2_multiplier, inp2_left_shift);
+      MPY_BY_QUANT_MACC_ST_ONE_EXP_X2X2_OUT32(raw_sum4_5, raw_sum6_7, shifted_a4_5, shifted_a6_7, inp1_multiplier, inp1_left_shift);
+      MPY_BY_QUANT_MACC_ST_ONE_EXP_X2X2_OUT32(raw_sum4_5, raw_sum6_7, shifted_b4_5, shifted_b6_7, inp2_multiplier, inp2_left_shift);
+      // Raw Output
+      out0_32 = out1_32 = out2_32 = out3_32 = AE_MOVDA32(out_zero_bias);
+      MPY_BY_QUANT_MACC_ST_ONE_EXP_X2X2_OUT32(out0_32, out1_32, raw_sum0_1, raw_sum2_3, out_multiplier, out_left_shift);
+      MPY_BY_QUANT_MACC_ST_ONE_EXP_X2X2_OUT32(out2_32, out3_32, raw_sum4_5, raw_sum6_7, out_multiplier, out_left_shift);
+      out0 = AE_SAT16X4(out0_32, out1_32);
+      out1 = AE_SAT16X4(out2_32, out3_32);
+      // Clamp output
+      LIMIT16X4(out2, out0, AE_MOVDA16(out_activation_min), AE_MOVDA16(out_activation_max));
+      LIMIT16X4(out3, out1, AE_MOVDA16(out_activation_min), AE_MOVDA16(out_activation_max));
+      AE_SA16X4_IP(out2, va_c, (ae_int16x4 *)p_c);
+      AE_SA16X4_IP(out3, va_c, (ae_int16x4 *)p_c);
+#else
+      raw_diff0_1 = raw_diff2_3 = raw_diff4_5 = raw_diff6_7 = AE_ZERO32();
+      // Calculate diff
+      MPY_BY_QUANT_MACC_ST_ONE_EXP_X2X2_OUT32(raw_diff0_1, raw_diff2_3, shifted_a0_1, shifted_a2_3, inp1_multiplier, inp1_left_shift);
+      MPY_BY_QUANT_MSUB_ST_ONE_EXP_X2X2_OUT32(raw_diff0_1, raw_diff2_3, shifted_b0_1, shifted_b2_3, inp2_multiplier, inp2_left_shift);
+      MPY_BY_QUANT_MACC_ST_ONE_EXP_X2X2_OUT32(raw_diff4_5, raw_diff6_7, shifted_a4_5, shifted_a6_7, inp1_multiplier, inp1_left_shift);
+      MPY_BY_QUANT_MSUB_ST_ONE_EXP_X2X2_OUT32(raw_diff4_5, raw_diff6_7, shifted_b4_5, shifted_b6_7, inp2_multiplier, inp2_left_shift);
+      // Square of diff
+        raw_diff0_1 = AE_SEL32_HH(AE_MOVINT32X2_FROMINT64(AE_SLAI64S(AE_MUL32_HH(raw_diff0_1, raw_diff0_1), 32)),AE_MOVINT32X2_FROMINT64(AE_SLAI64S(AE_MUL32_LL(raw_diff0_1, raw_diff0_1), 32)));
+        raw_diff2_3 = AE_SEL32_HH(AE_MOVINT32X2_FROMINT64(AE_SLAI64S(AE_MUL32_HH(raw_diff2_3, raw_diff2_3), 32)),AE_MOVINT32X2_FROMINT64(AE_SLAI64S(AE_MUL32_LL(raw_diff2_3, raw_diff2_3), 32)));
+        raw_diff4_5 = AE_SEL32_HH(AE_MOVINT32X2_FROMINT64(AE_SLAI64S(AE_MUL32_HH(raw_diff4_5, raw_diff4_5), 32)),AE_MOVINT32X2_FROMINT64(AE_SLAI64S(AE_MUL32_LL(raw_diff4_5, raw_diff4_5), 32)));
+        raw_diff6_7 = AE_SEL32_HH(AE_MOVINT32X2_FROMINT64(AE_SLAI64S(AE_MUL32_HH(raw_diff6_7, raw_diff6_7), 32)),AE_MOVINT32X2_FROMINT64(AE_SLAI64S(AE_MUL32_LL(raw_diff6_7, raw_diff6_7), 32)));
+
+      // Raw Output
+      out0_32 = out1_32 = out2_32 = out3_32 = 0;
+      MPY_BY_QUANT_MULT_SLS_X2_OUT32(out0_32, raw_diff0_1, out_multiplier, out_ls, out_rs);
+      MPY_BY_QUANT_MULT_SLS_X2_OUT32(out1_32, raw_diff2_3, out_multiplier, out_ls, out_rs);
+      MPY_BY_QUANT_MULT_SLS_X2_OUT32(out2_32, raw_diff4_5, out_multiplier, out_ls, out_rs);
+      MPY_BY_QUANT_MULT_SLS_X2_OUT32(out3_32, raw_diff6_7, out_multiplier, out_ls, out_rs);
+
+      CLAMP_VAL(out0_32, out0_32, AE_MOVDA32(out_activation_min), AE_MOVDA32(out_activation_max));
+      CLAMP_VAL(out1_32, out1_32, AE_MOVDA32(out_activation_min), AE_MOVDA32(out_activation_max));
+      CLAMP_VAL(out2_32, out2_32, AE_MOVDA32(out_activation_min), AE_MOVDA32(out_activation_max));
+      CLAMP_VAL(out3_32, out3_32, AE_MOVDA32(out_activation_min), AE_MOVDA32(out_activation_max));
+
+      ae_int16x4 outval = AE_SEL16_6420(AE_MOVINT16X4_FROMINT32X2(out0_32), AE_MOVINT16X4_FROMINT32X2(out1_32));
+      AE_SA16X4_IP(outval, va_c, (ae_int16x4 *)p_c);
+      outval = AE_SEL16_6420(AE_MOVINT16X4_FROMINT32X2(out2_32), AE_MOVINT16X4_FROMINT32X2(out3_32));
+      AE_SA16X4_IP(outval, va_c, (ae_int16x4 *)p_c);
+#endif
+    }
+    AE_SA64POS_FP(va_c, (ae_int16x4 *)p_c);
+  }
+
+  if(num_scalar_ops!=0){
+    for(i = 0; i < out_lc; i++)
+    {
+      ae_int32x2 out0_32;
+      p_a = (WORD16 *)&p_inp1[i * in_lc + (num_simd8_ops << 3)];
+      p_c = (WORD16 *)&p_out[i * in_lc + (num_simd8_ops << 3)];
+      p_b = (WORD16 *)&p_inp2[num_simd8_ops << 3];
+      for(j = 0; j< num_scalar_ops; j++)
+      {
+        b0_3 = AE_MOVDA16(p_b[j]);
+        a0_3 = AE_MOVDA16(p_a[j]);
+        AE_MUL16X4(shifted_a0_1, shifted_a2_3, a0_3, AE_MOVDA16(1));
+        AE_MUL16X4(shifted_b0_1, shifted_b2_3, b0_3, AE_MOVDA16(1));
+
+        shifted_a0_1 = AE_SLAA32S(shifted_a0_1, left_shift);
+        shifted_b0_1 = AE_SLAA32S(shifted_b0_1, left_shift);
+        raw_diff0_1 = AE_ZERO32();
+        MPY_BY_QUANT_MACC_ST_ONE_EXP_X2_OUT32(raw_diff0_1, shifted_a0_1, inp1_multiplier, inp1_left_shift);
+        MPY_BY_QUANT_MSUB_ST_ONE_EXP_X2_OUT32(raw_diff0_1, shifted_b0_1, inp2_multiplier, inp2_left_shift);
+        raw_diff0_1 = AE_SEL32_HH(AE_MOVINT32X2_FROMINT64(AE_SLAI64S(AE_MUL32_HH(raw_diff0_1, raw_diff0_1), 32)),AE_MOVINT32X2_FROMINT64(AE_SLAI64S(AE_MUL32_LL(raw_diff0_1, raw_diff0_1), 32)));
+        out0_32 = 0;
+        MPY_BY_QUANT_MULT_SLS_X2_OUT32(out0_32, raw_diff0_1, out_multiplier, out_ls, out_rs);
+        CLAMP_VAL(out0_32, out0_32, AE_MOVDA32(out_activation_min), AE_MOVDA32(out_activation_max));
+        ae_int16x4 outval = AE_SEL16_6420(AE_MOVINT16X4_FROMINT32X2(out0_32), AE_MOVINT16X4_FROMINT32X2(out0_32));
+        *p_c++ = (WORD16)(AE_MOVAD16_0(outval));
+      }
+    }
+  }
+
+  return;
+}
+
+static void internal_elm_squared_diff_broadcast_sym16sxsym16s_sym16s(WORD16 * __restrict__ p_out,
+                            WORD32  out_left_shift,
+                            WORD32  out_multiplier,
+                            WORD32  out_activation_min,
+                            WORD32  out_activation_max,
+                    const   WORD16 * __restrict__ p_inp1,
+                            WORD32  inp1_left_shift,
+                            WORD32  inp1_multiplier,
+                    const   WORD16 * __restrict__ p_inp2,
+                            WORD32  inp2_left_shift,
+                            WORD32  inp2_multiplier,
+                            WORD32  left_shift,
+                            WORD32  num_elm)
+{
+#if TFLITE_SINGLE_ROUNDING
+  WORD32 out_ls, out_rs;
+  out_ls = out_left_shift;
+  out_rs = out_left_shift;
+  (void)out_rs;
+#else
+  WORD32 out_ls, out_rs;
+  out_ls = out_left_shift > 0 ? out_left_shift : 0;
+  out_rs = out_left_shift < 0 ? -out_left_shift : 0;
+#endif
+
+  int i;
+  WORD16 * __restrict__ p_a = (WORD16 *)p_inp1;
+  WORD16 * __restrict__ p_b = (WORD16 *)p_inp2;
+  WORD16 *__restrict__ p_c =          p_out;
+
+  ae_int16x4 b;
+
+  ae_int16x4 a0_3;
+  ae_int32x2 shifted_a0_1, shifted_a2_3;
+  ae_int32x2 shifted_b0, shifted_b1;
+  ae_int32x2 scaled_b0;
+
+  ae_int32x2 raw_diff0_1, raw_diff2_3;
+
+  const int num_simd4_ops = num_elm >> 2;
+  const int num_scalar_ops = num_elm & 3;
+
+  {
+    ae_valign va_a;
+    va_a = AE_LA64_PP(p_a);
+    ae_valign va_c = AE_ZALIGN64();
+
+    b = AE_MOVDA16(p_b[0]);
+    AE_MUL16X4(shifted_b0, shifted_b1, b, AE_MOVDA16(1));
+
+    shifted_b0 = AE_SLAA32S(shifted_b0, left_shift);
+    shifted_b1 = AE_SLAA32S(shifted_b1, left_shift);
+
+    MPY_BY_QUANT_MULT_ST_ONE_EXP_X2_OUT32(scaled_b0, shifted_b0, inp2_multiplier, inp2_left_shift);
+
+    for(i=0; i<num_simd4_ops; i++)
+    {
+      ae_int32x2 out0_32, out1_32;
+      AE_LA16X4_IP(a0_3, va_a, (ae_int16x4 *)p_a);
+
+      AE_MUL16X4(shifted_a0_1, shifted_a2_3, a0_3, AE_MOVDA16(1));
+      shifted_a0_1 = AE_SLAA32S(shifted_a0_1, left_shift);
+      shifted_a2_3 = AE_SLAA32S(shifted_a2_3, left_shift);
+
+      /* Calculate squared diff */
+      raw_diff0_1 = raw_diff2_3 = scaled_b0;
+      MPY_BY_QUANT_MSUB_ST_ONE_EXP_X2X2_OUT32(raw_diff0_1, raw_diff2_3, shifted_a0_1, shifted_a2_3, inp1_multiplier, inp1_left_shift);
+      raw_diff0_1 = AE_SEL32_HH(AE_MOVINT32X2_FROMINT64(AE_SLAI64S(AE_MUL32_HH(raw_diff0_1, raw_diff0_1), 32)),AE_MOVINT32X2_FROMINT64(AE_SLAI64S(AE_MUL32_LL(raw_diff0_1, raw_diff0_1), 32)));
+      raw_diff2_3 = AE_SEL32_HH(AE_MOVINT32X2_FROMINT64(AE_SLAI64S(AE_MUL32_HH(raw_diff2_3, raw_diff2_3), 32)),AE_MOVINT32X2_FROMINT64(AE_SLAI64S(AE_MUL32_LL(raw_diff2_3, raw_diff2_3), 32)));
+
+      out0_32 = out1_32 = 0;
+      MPY_BY_QUANT_MULT_SLS_X2_OUT32(out0_32, raw_diff0_1, out_multiplier, out_ls, out_rs);
+      MPY_BY_QUANT_MULT_SLS_X2_OUT32(out1_32, raw_diff2_3, out_multiplier, out_ls, out_rs);
+      CLAMP_VAL(out0_32, out0_32, AE_MOVDA32(out_activation_min), AE_MOVDA32(out_activation_max));
+      CLAMP_VAL(out1_32, out1_32, AE_MOVDA32(out_activation_min), AE_MOVDA32(out_activation_max));
+      ae_int16x4 outval = AE_SEL16_6420(AE_MOVINT16X4_FROMINT32X2(out0_32), AE_MOVINT16X4_FROMINT32X2(out1_32));
+      AE_SA16X4_IP(outval, va_c, (ae_int16x4 *)p_c);
+    }
+    AE_SA64POS_FP(va_c, p_c);
+  }
+
+  b = AE_MOVDA16(p_b[0]);
+  AE_MUL16X4(shifted_b0, shifted_b1, b, AE_MOVDA16(1));
+
+  shifted_b0 = AE_SLAA32S(shifted_b0, left_shift);
+  shifted_b1 = AE_SLAA32S(shifted_b1, left_shift);
+
+  MPY_BY_QUANT_MULT_ST_ONE_EXP_X2_OUT32(scaled_b0, shifted_b0, inp2_multiplier, inp2_left_shift);
+
+  for(i=0; i<num_scalar_ops; i++)
+  {
+    ae_int32x2 out0_32;
+    a0_3 = AE_MOVDA16(p_a[i]);
+
+    AE_MUL16X4(shifted_a0_1, shifted_a2_3, a0_3, AE_MOVDA16(1));
+    shifted_a0_1 = AE_SLAA32S(shifted_a0_1, left_shift);
+    shifted_a2_3 = AE_SLAA32S(shifted_a2_3, left_shift);
+
+    raw_diff0_1 = raw_diff2_3 = scaled_b0;
+    MPY_BY_QUANT_MSUB_ST_ONE_EXP_X2_OUT32(raw_diff0_1, shifted_a0_1, inp1_multiplier, inp1_left_shift);
+    raw_diff0_1 = AE_SEL32_HH(AE_MOVINT32X2_FROMINT64(AE_SLAI64S(AE_MUL32_HH(raw_diff0_1, raw_diff0_1), 32)),AE_MOVINT32X2_FROMINT64(AE_SLAI64S(AE_MUL32_LL(raw_diff0_1, raw_diff0_1), 32)));
+    out0_32 = 0;
+    MPY_BY_QUANT_MULT_SLS_X2_OUT32(out0_32, raw_diff0_1, out_multiplier, out_ls, out_rs);
+    CLAMP_VAL(out0_32, out0_32, AE_MOVDA32(out_activation_min), AE_MOVDA32(out_activation_max));
+    ae_int16x4 outval = AE_SEL16_6420(AE_MOVINT16X4_FROMINT32X2(out0_32), AE_MOVINT16X4_FROMINT32X2(out0_32));
+    *p_c = (WORD16)(AE_MOVAD16_3(outval));
+    p_c++;
+  }
+
+  return;
+}
+
+WORD32 xa_nn_elm_squared_diff_broadcast_4D_sym16sxsym16s_sym16s(WORD16 * __restrict__ p_out,
+                      const WORD32 *const p_out_shape,
+                            WORD32  out_left_shift,
+                            WORD32  out_multiplier,
+                            WORD32  out_activation_min,
+                            WORD32  out_activation_max,
+                      const WORD16 * __restrict__ p_inp1,
+                      const WORD32 *const p_inp1_shape,
+                            WORD32  inp1_left_shift,
+                            WORD32  inp1_multiplier,
+                      const WORD16 * __restrict__ p_inp2,
+                      const WORD32 *const p_inp2_shape,
+                            WORD32  inp2_left_shift,
+                            WORD32  inp2_multiplier,
+                            WORD32  left_shift)
+{
+  /* NULL pointer checks */
+  XA_NNLIB_ARG_CHK_PTR(p_out, -1);
+  XA_NNLIB_ARG_CHK_PTR(p_inp1, -1);
+  XA_NNLIB_ARG_CHK_PTR(p_inp2, -1);
+  XA_NNLIB_ARG_CHK_PTR(p_out_shape, -1);
+  XA_NNLIB_ARG_CHK_PTR(p_inp1_shape, -1);
+  XA_NNLIB_ARG_CHK_PTR(p_inp2_shape, -1);
+  /* Pointer alignment checks */
+  XA_NNLIB_ARG_CHK_ALIGN(p_out, sizeof(WORD16), -1);
+  XA_NNLIB_ARG_CHK_ALIGN(p_inp1, sizeof(WORD16), -1);
+  XA_NNLIB_ARG_CHK_ALIGN(p_inp2, sizeof(WORD16), -1);
+  XA_NNLIB_ARG_CHK_ALIGN(p_out_shape, sizeof(WORD32), -1);
+  XA_NNLIB_ARG_CHK_ALIGN(p_inp1_shape, sizeof(WORD32), -1);
+  XA_NNLIB_ARG_CHK_ALIGN(p_inp2_shape, sizeof(WORD32), -1);
+  /* Basic Parameter checks */
+  XA_NNLIB_ARG_CHK_COND((( out_left_shift < -31) || ( out_left_shift > 31)), -1);
+  XA_NNLIB_ARG_CHK_COND(((inp1_left_shift < -31) || (inp1_left_shift > 0)), -1);
+  XA_NNLIB_ARG_CHK_COND(((inp2_left_shift < -31) || (inp2_left_shift > 0)), -1);
+  XA_NNLIB_ARG_CHK_COND((left_shift != 0), -1);
+  XA_NNLIB_ARG_CHK_COND(((out_activation_min < -32768) || (out_activation_min > 32767)), -1);
+  XA_NNLIB_ARG_CHK_COND(((out_activation_max < -32768) || (out_activation_max > 32767)), -1);
+  XA_NNLIB_ARG_CHK_COND((out_activation_max < out_activation_min), -1);
+
+  /* Check shapes */
+  int i;
+  for(i = 0; i < 4; i++)
+  {
+    if((p_inp1_shape[i] != p_inp2_shape[i] && p_inp1_shape[i] != 1 && p_inp2_shape[i] != 1) ||
+       (p_out_shape[i] != (p_inp1_shape[i] > p_inp2_shape[i] ? p_inp1_shape[i] : p_inp2_shape[i])))
+    {
+      return -1;
+    }
+  }
+
+  WORD32 inp1_strides[4], inp2_strides[4];
+  inp1_strides[3] = 1;
+  inp2_strides[3] = 1;
+  for(i = 2; i >= 0; i--)
+  {
+    ae_int32x2 d_str, d_shape;
+    d_str = AE_MOVDA32X2(inp1_strides[i + 1], inp2_strides[i + 1]);
+    d_shape = AE_MOVDA32X2(p_inp1_shape[i + 1], p_inp2_shape[i + 1]);
+    d_str = AE_MULP32X2(d_str, d_shape);
+    inp1_strides[i] = AE_MOVAD32_H(d_str);
+    inp2_strides[i] = AE_MOVAD32_L(d_str);
+  }
+
+  int need_broadcast = 0;
+  int inp1_const = 1, inp2_const = 1;
+  for(i = 0; i < 4; i++)
+  {
+    if(p_inp1_shape[i] != p_inp2_shape[i])
+    {
+      if(p_inp1_shape[i] == 1)
+        inp1_strides[i] = 0;
+      else
+        inp2_strides[i] = 0;
+
+      need_broadcast = 1;
+    }
+    if(p_inp1_shape[i] != 1)
+      inp1_const &= 0;
+    if(p_inp2_shape[i] != 1)
+      inp2_const &= 0;
+  }
+  int itr0, itr1, itr2;
+
+  WORD16 *p_out_tmp = p_out;
+  const WORD16 *__restrict__ p_inp1_tmp = p_inp1;
+  const WORD16 *__restrict__ p_inp2_tmp = p_inp2;
+
+  if(need_broadcast == 0)
+  {
+    internal_elm_squared_diff_broadcast_2D_sym16sxsym16s_sym16s(
+                p_out,
+                out_left_shift,
+                out_multiplier,
+                out_activation_min,
+                out_activation_max,
+                p_inp1,
+                inp1_left_shift,
+                inp1_multiplier,
+                p_inp2,
+                inp2_left_shift,
+                inp2_multiplier,
+                left_shift,
+                1,
+                p_out_shape[0] * inp1_strides[0]);
+  }
+  else if(inp1_strides[3] == inp2_strides[3])
+  {
+    WORD32 in_lc, out_lc;
+    WORD32 inp1_ls, inp1_mult;
+    WORD32 inp2_ls, inp2_mult;
+
+    inp1_ls = inp1_left_shift;
+    inp1_mult = inp1_multiplier;
+    inp2_ls = inp2_left_shift;
+    inp2_mult = inp2_multiplier;
+
+    in_lc = p_out_shape[2] * p_out_shape[3];
+    out_lc = 1;
+    if(inp1_strides[2] == 0)
+    {
+      inp2_ls = inp1_left_shift;
+      inp2_mult = inp1_multiplier;
+      inp1_ls = inp2_left_shift;
+      inp1_mult = inp2_multiplier;
+      const WORD16 *tmp;
+      tmp = p_inp1_tmp;   p_inp1_tmp = p_inp2_tmp;    p_inp2_tmp = tmp;
+
+      int tmp_strides[2];
+      tmp_strides[0] = inp1_strides[0];
+      tmp_strides[1] = inp1_strides[1];
+
+      inp1_strides[0] = inp2_strides[0];
+      inp1_strides[1] = inp2_strides[1];
+
+      inp2_strides[0] = tmp_strides[0];
+      inp2_strides[1] = tmp_strides[1];
+      in_lc = p_out_shape[3];
+      out_lc = p_out_shape[2];
+    }
+    else if(inp2_strides[2] == 0)
+    {
+      in_lc = p_out_shape[3];
+      out_lc = p_out_shape[2];
+    }
+
+   for(itr0 = 0; itr0 < p_out_shape[0]; itr0++)
+    {
+      const WORD16 *__restrict__ p_inp1_tmp0 = p_inp1_tmp;
+      const WORD16 *__restrict__ p_inp2_tmp0 = p_inp2_tmp;
+      for(itr1 = 0; itr1 < p_out_shape[1]; itr1++)
+      {
+        internal_elm_squared_diff_broadcast_2D_sym16sxsym16s_sym16s(
+            p_out_tmp,
+            out_left_shift,
+            out_multiplier,
+            out_activation_min,
+            out_activation_max,
+            p_inp1_tmp0,
+            inp1_ls,
+            inp1_mult,
+            p_inp2_tmp0,
+            inp2_ls,
+            inp2_mult,
+            left_shift,
+            out_lc,
+            in_lc);
+        p_out_tmp += in_lc * out_lc;
+        p_inp1_tmp0 += inp1_strides[1];
+        p_inp2_tmp0 += inp2_strides[1];
+      }
+      p_inp1_tmp += inp1_strides[0];
+      p_inp2_tmp += inp2_strides[0];
+    }
+  }
+  else if(inp1_const == 1 || inp2_const == 1)
+  {
+    WORD32 inp1_ls, inp1_mult;
+    WORD32 inp2_ls, inp2_mult;
+    inp1_ls = inp1_left_shift;
+    inp1_mult = inp1_multiplier;
+    inp2_ls = inp2_left_shift;
+    inp2_mult = inp2_multiplier;
+    if(inp1_strides[3] == 0)
+    {
+      inp2_ls = inp1_left_shift;
+      inp2_mult = inp1_multiplier;
+      inp1_ls = inp2_left_shift;
+      inp1_mult = inp2_multiplier;
+      const WORD16 *tmp;
+      tmp = p_inp1_tmp;   p_inp1_tmp = p_inp2_tmp;    p_inp2_tmp = tmp;
+    }
+
+    internal_elm_squared_diff_broadcast_sym16sxsym16s_sym16s(
+        p_out_tmp,
+        out_left_shift,
+        out_multiplier,
+        out_activation_min,
+        out_activation_max,
+        p_inp1_tmp,
+        inp1_ls,
+        inp1_mult,
+        p_inp2_tmp,
+        inp2_ls,
+        inp2_mult,
+        left_shift,
+        p_out_shape[0] * p_out_shape[1] * p_out_shape[2] * p_out_shape[3]);
+  }
+  else
+  {
+    WORD32 inp1_ls, inp1_mult;
+    WORD32 inp2_ls, inp2_mult;
+    inp1_ls = inp1_left_shift;
+    inp1_mult = inp1_multiplier;
+    inp2_ls = inp2_left_shift;
+    inp2_mult = inp2_multiplier;
+    if(inp1_strides[3] == 0)
+    {
+      inp2_ls = inp1_left_shift;
+      inp2_mult = inp1_multiplier;
+      inp1_ls = inp2_left_shift;
+      inp1_mult = inp2_multiplier;
+      const WORD16 *tmp;
+      tmp = p_inp1_tmp;   p_inp1_tmp = p_inp2_tmp;    p_inp2_tmp = tmp;
+
+      int tmp_strides[3];
+      tmp_strides[0] = inp1_strides[0];
+      tmp_strides[1] = inp1_strides[1];
+      tmp_strides[2] = inp1_strides[2];
+
+      inp1_strides[0] = inp2_strides[0];
+      inp1_strides[1] = inp2_strides[1];
+      inp1_strides[2] = inp2_strides[2];
+
+      inp2_strides[0] = tmp_strides[0];
+      inp2_strides[1] = tmp_strides[1];
+      inp2_strides[2] = tmp_strides[2];
+    }
+    for(itr0 = 0; itr0 < p_out_shape[0]; itr0++)
+    {
+      const WORD16 *__restrict__ p_inp1_tmp0 = p_inp1_tmp;
+      const WORD16 *__restrict__ p_inp2_tmp0 = p_inp2_tmp;
+      for(itr1 = 0; itr1 < p_out_shape[1]; itr1++)
+      {
+        const WORD16 *__restrict__ p_inp1_tmp1 = p_inp1_tmp0;
+        const WORD16 *__restrict__ p_inp2_tmp1 = p_inp2_tmp0;
+        for(itr2 = 0; itr2 < p_out_shape[2]; itr2++)
+        {
+          {
+            internal_elm_squared_diff_broadcast_sym16sxsym16s_sym16s(
+                p_out_tmp,
+                out_left_shift,
+                out_multiplier,
+                out_activation_min,
+                out_activation_max,
+                p_inp1_tmp1,
+                inp1_ls,
+                inp1_mult,
+                p_inp2_tmp1,
+                inp2_ls,
+                inp2_mult,
+                left_shift,
+                p_out_shape[3]);
+          }
+          p_out_tmp += p_out_shape[3];
+          p_inp1_tmp1 += inp1_strides[2];
+          p_inp2_tmp1 += inp2_strides[2];
+        }
+        p_inp1_tmp0 += inp1_strides[1];
+        p_inp2_tmp0 += inp2_strides[1];
+      }
+      p_inp1_tmp += inp1_strides[0];
+      p_inp2_tmp += inp2_strides[0];
+    }
+  }
+  return 0;
+}
diff --git a/algo/kernels/basic/hifi4/xa_nn_lstm_utils.c b/algo/kernels/basic/hifi4/xa_nn_lstm_utils.c
index 7655d30..f43d8a2 100644
--- a/algo/kernels/basic/hifi4/xa_nn_lstm_utils.c
+++ b/algo/kernels/basic/hifi4/xa_nn_lstm_utils.c
@@ -105,8 +105,8 @@ WORD32 xa_nn_lstm_cell_state_update_16(WORD16* p_cell_state,
   XA_NNLIB_ARG_CHK_ALIGN(p_cell_gate, sizeof(WORD16), -1);
   XA_NNLIB_ARG_CHK_ALIGN(p_input_gate, sizeof(WORD16), -1);
   /* Basic Parameter checks */
-  XA_NNLIB_ARG_CHK_COND((cell_to_forget_shift < -31 || cell_to_forget_shift > -15), -1);
-  XA_NNLIB_ARG_CHK_COND((cell_to_input_shift < -31 || cell_to_input_shift > -15), -1);
+  XA_NNLIB_ARG_CHK_COND((cell_to_forget_shift < -31 || cell_to_forget_shift > -1), -1);
+  XA_NNLIB_ARG_CHK_COND((cell_to_input_shift < -31 || cell_to_input_shift > -1), -1);
   XA_NNLIB_ARG_CHK_COND((num_elms < 0), -1);
 
   WORD32 ctof_right_shift, ctoi_right_shift;
diff --git a/algo/kernels/basic/hifi4/xa_nn_reduce_asym16s_asym16s.c b/algo/kernels/basic/hifi4/xa_nn_reduce_asym16s_asym16s.c
new file mode 100644
index 0000000..f203dac
--- /dev/null
+++ b/algo/kernels/basic/hifi4/xa_nn_reduce_asym16s_asym16s.c
@@ -0,0 +1,1164 @@
+/*******************************************************************************
+* Copyright (c) 2018-2023 Cadence Design Systems, Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining
+* a copy of this software and associated documentation files (the
+* "Software"), to use this Software with Cadence processor cores only and
+* not with any other processors and platforms, subject to
+* the following conditions:
+*
+* The above copyright notice and this permission notice shall be included
+* in all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************************/
+#include "xa_nnlib_common.h"
+#include <string.h>
+#include "xa_nn_basic_state.h"
+#include "xa_nnlib_common_macros.h"
+
+#define ALIGNMENT_8   8
+
+static WORD32 xa_nn_memset_16(WORD16 *p_dst, WORD16 val, WORD32 n)
+{
+  int i;
+  ae_int16x4 d_inp0 = AE_MOVDA16(val);
+  WORD16 *ptr_dst = (WORD16 *)p_dst;
+  ae_valign dst_align = AE_ZALIGN64();
+  for (i = 0; i < n >> 2 ; i++)
+  {
+     AE_SA16X4_IP(d_inp0, dst_align, (ae_int16x4 *)ptr_dst);
+  }
+  AE_SA64POS_FP(dst_align, ptr_dst);
+  for (i = 0; i < (n & 3) ; i++)
+  {
+    *ptr_dst++ = val;
+  }
+  return 0;
+}
+
+static void vecmax16_inpx3(const WORD16 *p_src1, const WORD16* p_src2, const WORD16* p_src3, WORD16 * /*__restrict__*/ p_dst, int N){
+    int i = 0;
+    ae_valign align_src1, align_src2, align_src3, align_dst;
+    align_src1 = AE_LA64_PP(p_src1);
+    align_src2 = AE_LA64_PP(p_src2);
+    align_src3 = AE_LA64_PP(p_src3);
+    align_dst = AE_ZALIGN64();
+
+    for(i=0; i < (N >> 3); i++)
+    {
+      ae_int16x4 i1, j1, k1, i2, j2 ,k2;
+      xtbool4 b1, b2;
+      AE_LA16X4_IP(i1, align_src1, (ae_int16x4 *)p_src1);
+      AE_LA16X4_IP(j1, align_src2, (ae_int16x4 *)p_src2);
+      AE_LA16X4_IP(k1, align_src3, (ae_int16x4 *)p_src3);
+      AE_LA16X4_IP(i2, align_src1, (ae_int16x4 *)p_src1);
+      AE_LA16X4_IP(j2, align_src2, (ae_int16x4 *)p_src2);
+      AE_LA16X4_IP(k2, align_src3, (ae_int16x4 *)p_src3);
+      b1 = AE_LT16(i1, j1);
+      b2 = AE_LT16(i2, j2);
+      AE_MOVT16X4(i1, j1, b1);
+      AE_MOVT16X4(i2, j2, b2);
+      b1 = AE_LT16(i1, k1);
+      b2 = AE_LT16(i2, k2);
+      AE_MOVT16X4(i1, k1, b1);
+      AE_MOVT16X4(i2, k2, b2);
+      AE_SA16X4_IP(i1, align_dst, (ae_int16x4 *)p_dst);
+      AE_SA16X4_IP(i2, align_dst, (ae_int16x4 *)p_dst);
+    }
+    AE_SA64POS_FP(align_dst, p_dst);
+    //Remainder Loop
+    for(i = 0; i < (N & 7); i++)
+    {
+      ae_int32x2 i1, j1, k1, out1;
+      i1 = (WORD32) *(p_src1 + i);
+      j1 = (WORD32) *(p_src2 + i);
+      k1 = (WORD32) *(p_src3 + i);
+      out1 = AE_MAX32(i1, j1);
+      out1 = AE_MAX32(out1, k1);
+      *p_dst++ = (WORD16) AE_MOVAD32_H(out1);
+    }
+}
+
+static void vecmax16_inpx2(const WORD16 *p_src1, const WORD16* p_src2, WORD16 *p_dst, int N){
+    int i = 0;
+    ae_valign align_src1, align_src2, align_dst;
+    align_src1 = AE_LA64_PP(p_src1);
+    align_src2 = AE_LA64_PP(p_src2);
+    align_dst = AE_ZALIGN64();
+    for(i=0; i < (N >> 3); i++)
+    {
+      ae_int16x4 i1, j1, i2, j2;
+      xtbool4 b1, b2;
+      AE_LA16X4_IP(i1, align_src1, (ae_int16x4 *)p_src1);
+      AE_LA16X4_IP(j1, align_src2, (ae_int16x4 *)p_src2);
+      AE_LA16X4_IP(i2, align_src1, (ae_int16x4 *)p_src1);
+      AE_LA16X4_IP(j2, align_src2, (ae_int16x4 *)p_src2);
+      b1 = AE_LT16(i1, j1);
+      b2 = AE_LT16(i2, j2);
+      AE_MOVT16X4(i1, j1, b1);
+      AE_MOVT16X4(i2, j2, b2);
+      AE_SA16X4_IP(i1, align_dst, (ae_int16x4 *)p_dst);
+      AE_SA16X4_IP(i2, align_dst, (ae_int16x4 *)p_dst);
+    }
+    AE_SA64POS_FP(align_dst, p_dst);
+    //Remainder Loop
+    for(i = 0; i < (N & 7); i++)
+    {
+      ae_int32x2 i1, j1, out1;
+      i1 = (WORD32) *(p_src1 + i);
+      j1 = (WORD32) *(p_src2 + i);
+      out1 = AE_MAX32(i1, j1);
+      *p_dst++ = (WORD16) AE_MOVAD32_H(out1);
+    }
+}
+
+WORD32 xa_nn_reduce_max_4D_asym16s_asym16s(WORD16 * __restrict__ p_out
+                                           ,const WORD32 *const p_out_shape
+                                           ,const WORD16 * __restrict__ p_inp
+                                           ,const WORD32 *const p_inp_shape
+                                           ,const WORD32 * __restrict__ p_axis
+                                           ,WORD32 num_out_dims
+                                           ,WORD32 num_inp_dims
+                                           ,WORD32 num_axis_dims
+                                           ,pVOID p_scratch_in)
+{
+  /* NULL pointer checks */
+  XA_NNLIB_ARG_CHK_PTR(p_out, -1);
+  XA_NNLIB_ARG_CHK_PTR(p_inp, -1);
+  XA_NNLIB_ARG_CHK_PTR(p_axis, -1);
+  XA_NNLIB_ARG_CHK_PTR(p_out_shape, -1);
+  XA_NNLIB_ARG_CHK_PTR(p_inp_shape, -1);
+
+  /* Invalid input checks */
+  XA_NNLIB_ARG_CHK_COND(((num_inp_dims <= 0) || (num_inp_dims > 4)), -1);
+  XA_NNLIB_ARG_CHK_COND(((num_out_dims <= 0) || (num_out_dims > 4)), -1);
+  XA_NNLIB_ARG_CHK_COND(((num_axis_dims < 0) || (num_axis_dims > 4)), -1);
+
+  int axis_itr = 0, inp_itr = 0, out_itr = 0;
+  for(axis_itr=0; axis_itr < num_axis_dims; axis_itr++)
+  {
+    XA_NNLIB_ARG_CHK_COND(((p_axis[axis_itr] < 0) || (p_axis[axis_itr] > (num_inp_dims - 1))), -1);
+  }
+
+  for(inp_itr=0; inp_itr < num_inp_dims; inp_itr++)
+  {
+    XA_NNLIB_ARG_CHK_COND((p_inp_shape[inp_itr] <= 0), -1);
+  }
+
+  int out_length = 1;
+  for(out_itr=0; out_itr < num_out_dims; out_itr++)
+  {
+    XA_NNLIB_ARG_CHK_COND((p_out_shape[out_itr] <= 0), -1);
+    out_length *= p_out_shape[out_itr];
+  }
+
+  /* Pointer alignment checks */
+  XA_NNLIB_ARG_CHK_ALIGN(p_out, sizeof(WORD16), -1);
+  XA_NNLIB_ARG_CHK_ALIGN(p_inp, sizeof(WORD16), -1);
+  XA_NNLIB_ARG_CHK_ALIGN(p_axis, sizeof(WORD32), -1);
+  XA_NNLIB_ARG_CHK_ALIGN(p_out_shape, sizeof(WORD32), -1);
+  XA_NNLIB_ARG_CHK_ALIGN(p_inp_shape, sizeof(WORD32), -1);
+
+  WORD16 *p_in = (WORD16 *)(p_inp);
+  WORD16 *p_scratch = (WORD16 *)(p_scratch_in);
+
+  // Changing order of axis data so that reduce max will be first computed
+  // across largest inp shape dim in axis. This is required to
+  // minimize the scratch usage.
+  int inp_length = 1, p_axis_data[4], inp_shape_max;
+  if(num_axis_dims)
+  {
+    inp_shape_max = p_inp_shape[p_axis[0]];
+    axis_itr = 1;
+    int max_axis_itr = 0;
+    int temp_p_axis_0 = p_axis[0];
+    for(axis_itr = 0; axis_itr < num_axis_dims; axis_itr++)
+    {
+      p_axis_data[axis_itr] = p_axis[axis_itr];
+    }
+    for(axis_itr = 1; axis_itr < num_axis_dims; axis_itr++)
+    {
+      if(p_inp_shape[p_axis[axis_itr]] > inp_shape_max)
+      {
+        inp_shape_max = p_inp_shape[p_axis[axis_itr]];
+        max_axis_itr = axis_itr;
+      }
+    }
+    p_axis_data[0] = p_axis_data[max_axis_itr];
+    p_axis_data[max_axis_itr] = temp_p_axis_0;
+
+    inp_itr = 0;
+    for(inp_itr=0; inp_itr < num_inp_dims; inp_itr++)
+    {
+      inp_length *= p_inp_shape[inp_itr];
+    }
+
+    xa_nn_memset_16(p_scratch, -32768, (inp_length / inp_shape_max)); //TODO: Alternate approach for memset?
+  }
+
+  // Promoting lesser dim tensors to 4D tensors. Also modifying axis
+  // data accordingly.
+  int p_4D_inp_shape[4] = {1, 1, 1, 1};
+  int itr = num_inp_dims - 1;
+  int count = 3;
+  while(itr >= 0)
+  {
+    p_4D_inp_shape[count] = p_inp_shape[itr];
+    itr--;
+    count--;
+  }
+  for(itr = 0; itr < num_axis_dims; itr++)
+  {
+    p_axis_data[itr] = p_axis_data[itr] + (4 - num_inp_dims);
+  }
+
+  int temp_inp_n = p_4D_inp_shape[0];
+  int temp_inp_h = p_4D_inp_shape[1];
+  int temp_inp_w = p_4D_inp_shape[2];
+  int temp_inp_c = p_4D_inp_shape[3];
+
+  int flag = 0;
+  int itr_axis, itr_n, itr_h, itr_w, itr_c;
+  WORD16 *p_src1, *p_src2, *p_src3;
+  WORD16 * p_dst;
+
+  for(itr_axis=0; itr_axis < num_axis_dims; itr_axis++)
+  {
+    switch(p_axis_data[itr_axis])
+    {
+      case 0: {
+        int plane_size = temp_inp_h * temp_inp_w * temp_inp_c;
+
+        for(itr_n=0; itr_n < (temp_inp_n & ~(2 - 1)); itr_n += 2)
+        {
+          p_src1 = p_scratch;
+          p_src2 = p_in + itr_n * plane_size;
+          p_src3 = p_in + (itr_n + 1) * plane_size;
+          p_dst  = p_scratch;
+
+          vecmax16_inpx3(p_src1,p_src2,p_src3,p_dst,plane_size);
+        }
+        if(temp_inp_n & 1)
+        {
+          p_src1 = p_scratch;
+          p_src2 = p_in + itr_n * plane_size;
+          p_dst  = p_scratch;
+          vecmax16_inpx2(p_src1, p_src2, p_dst, plane_size);
+        }
+        temp_inp_n = 1;
+        }break;
+      case 1: {
+        int plane_size = temp_inp_h * temp_inp_w * temp_inp_c;
+        int wc_plane_size = temp_inp_w * temp_inp_c;
+        for(itr_n=0; itr_n < (temp_inp_n); itr_n++)
+        {
+          p_src1 = p_scratch + (itr_n * wc_plane_size * (!flag)) + (flag * itr_n * plane_size);
+          for(itr_h=0; itr_h < (temp_inp_h & ~(2 - 1)); itr_h += 2)
+          {
+            p_src2 = p_in + (itr_n * plane_size) + (itr_h * wc_plane_size);
+            p_src3 = p_in + (itr_n * plane_size) + ((itr_h + 1) * wc_plane_size);
+            p_dst = p_scratch + (itr_n * wc_plane_size);
+
+            vecmax16_inpx3(p_src1,p_src2,p_src3,p_dst,wc_plane_size);
+            p_src1 = p_scratch + (itr_n * wc_plane_size);
+          }
+
+          if(temp_inp_h & 1)
+          {
+            p_src2 = p_in + (itr_n * plane_size) + (itr_h * wc_plane_size);
+            p_dst = p_scratch + (itr_n * wc_plane_size);
+
+            vecmax16_inpx2(p_src1, p_src2, p_dst, wc_plane_size);
+            p_src1 = p_scratch + (itr_n * wc_plane_size);
+          }
+        }
+        temp_inp_h = 1;
+        }break;
+      case 2:{
+        int plane_size = temp_inp_h * temp_inp_w * temp_inp_c;
+        int wc_plane_size = temp_inp_w * temp_inp_c;
+        int hc_plane_size = temp_inp_h * temp_inp_c;
+        for(itr_n=0; itr_n < (temp_inp_n); itr_n++)
+        {
+          for(itr_h=0; itr_h < (temp_inp_h); itr_h++)
+          {
+            p_src1 = p_scratch + (((itr_n * hc_plane_size) + itr_h * temp_inp_c) * (!flag)) + (flag)*((itr_n * plane_size) + (itr_h * wc_plane_size));
+            for(itr_w=0; itr_w < (temp_inp_w & ~(2 - 1)); itr_w += 2)
+            {
+              p_src2 = p_in + (itr_n * plane_size) + (itr_h * wc_plane_size) + (itr_w * temp_inp_c);
+              p_src3 = p_in + (itr_n * plane_size) + (itr_h * wc_plane_size) + ((itr_w + 1) * temp_inp_c);
+              p_dst = p_scratch + (itr_n * hc_plane_size) + itr_h * temp_inp_c;
+
+              vecmax16_inpx3(p_src1,p_src2,p_src3,p_dst,temp_inp_c);
+
+              p_src1 = p_scratch + (itr_n * hc_plane_size) + (itr_h * temp_inp_c);
+            }
+
+            if(temp_inp_w & 1)
+            {
+              p_src2 = p_in + (itr_n * plane_size) + (itr_h * wc_plane_size) + (itr_w * temp_inp_c);
+              p_dst = p_scratch + (itr_n * hc_plane_size) + itr_h * temp_inp_c;
+
+              vecmax16_inpx2(p_src1, p_src2, p_dst, temp_inp_c);
+              p_src1 = p_scratch + (itr_n * hc_plane_size) + (itr_h * temp_inp_c);
+            }
+          }
+        }
+        temp_inp_w = 1;
+        }break;
+      case 3: {
+        int plane_size = temp_inp_h * temp_inp_w * temp_inp_c;
+        int wc_plane_size = temp_inp_w * temp_inp_c;
+        int hw_plane_size = temp_inp_h * temp_inp_w;
+        int rem_c = (temp_inp_c & 7);
+        for(itr_n=0; itr_n < (temp_inp_n); itr_n++)
+        {
+          for(itr_h=0; itr_h < (temp_inp_h); itr_h++)
+          {
+            for(itr_w=0; itr_w < (temp_inp_w); itr_w++)
+            {
+              p_src1 = p_scratch + (((itr_n * hw_plane_size) + (itr_h * temp_inp_w) + itr_w) * (!flag)) + ((flag) * ((itr_n * plane_size) + (itr_h * wc_plane_size) + (itr_w *temp_inp_c)));
+              p_src2 = p_in + (itr_n * plane_size) + (itr_h * wc_plane_size) + (itr_w * temp_inp_c);
+              p_dst = p_scratch + (itr_n * hw_plane_size) + (itr_h * temp_inp_w) + itr_w;
+              ae_valign align_src2 = AE_LA64_PP(p_src2);
+
+              for(itr_c=0; itr_c < (temp_inp_c >> 3); itr_c++)
+              {
+                WORD16 k1, k2, k3;
+                ae_int16x4 j1, j2;
+                ae_int32x2 out1, out2;
+                k1 = AE_L16_I((ae_int16 *)p_src1, 0);
+                AE_LA16X4_IP(j1, align_src2, (ae_int16x4 *)p_src2);
+                AE_LA16X4_IP(j2, align_src2, (ae_int16x4 *)p_src2);
+
+                k2 = AE_INT16X4_RMAX(j1);
+                k3 = AE_INT16X4_RMAX(j2);
+                out1 = AE_MAX32(AE_MOVDA32(k2), AE_MOVDA32(k3));
+                out2 = AE_MAX32(k1, out1);
+                *p_dst = (WORD16) AE_MOVAD32_H(out2);
+                p_src1 = p_dst;
+              }
+
+              //Remainder Loop
+              #pragma no_unroll
+              for(itr_c=0; itr_c < rem_c; itr_c++)
+              {
+                WORD16 k1, k2;
+                ae_int16x4 j1;
+                ae_int32x2 out1;
+                k1 = AE_L16_I((ae_int16 *)p_src1, 0);
+                AE_L16_IP(j1, (ae_int16 *)p_src2, 2);
+                k2 = AE_INT16X4_RMAX(j1);
+                out1 = AE_MAX32(AE_MOVDA32(k1), AE_MOVDA32(k2));
+                *p_dst = (WORD16) AE_MOVAD32_H(out1);
+                p_src1 = p_dst;
+              }
+            }
+          }
+        }
+        temp_inp_c = 1;
+        }break;
+      default:
+        return -1;
+        break;
+    }
+
+    p_in = p_scratch;
+    flag = 1;
+  }
+  if(num_axis_dims)
+  {
+    memcpy(p_out, p_scratch, out_length*sizeof(WORD16));
+  }
+  else
+  {
+    memcpy(p_out, p_inp, inp_length*sizeof(WORD16));
+  }
+
+  return 0;
+}
+
+static void vecmean16_inpx3(const ae_int32x2 *p_src1, const WORD16* p_src2, const WORD16* p_src3, ae_int32x2 *p_dst, int N){
+  int i = 0;
+  ae_int32x2 ONE32 = AE_MOVDA32(1);
+  ae_valign align_src1, align_dst;
+  ae_valign align_src2, align_src3;
+  align_src1 = AE_LA64_PP(p_src1);
+  align_src2 = AE_LA64_PP(p_src2);
+  align_src3 = AE_LA64_PP(p_src3);
+  align_dst = AE_ZALIGN64();
+
+  for(i=0; i < (N >> 2); i++)
+  {
+    ae_int16x4 j1, j2;
+    ae_int32x2 j1_32_h, j1_32_l;
+    ae_int32x2 j2_32_h, j2_32_l;
+    ae_int32x2 wj1_32_h, wj1_32_l;
+
+    ae_int32x2 wout1, wout2;
+    AE_LA32X2_IP(wout1, align_src1, p_src1);
+    AE_LA32X2_IP(wout2, align_src1, p_src1);
+
+    AE_LA16X4_IP(j1, align_src2, (ae_int16x4 *)p_src2);
+    AE_LA16X4_IP(j2, align_src3, (ae_int16x4 *)p_src3);
+
+    j1_32_h = AE_SEXT32X2D16_32(j1);
+    j1_32_l = AE_SEXT32X2D16_10(j1);
+    j2_32_h = AE_SEXT32X2D16_32(j2);
+    j2_32_l = AE_SEXT32X2D16_10(j2);
+
+    wj1_32_h = AE_ADD32(j1_32_h, j2_32_h);
+    wj1_32_l = AE_ADD32(j1_32_l, j2_32_l);
+
+    AE_MULAP32X2(wout1, wj1_32_h, ONE32);
+    AE_MULAP32X2(wout2, wj1_32_l, ONE32);
+
+    AE_SA32X2_IP(wout1, align_dst, p_dst);
+    AE_SA32X2_IP(wout2, align_dst, p_dst);
+  }
+  AE_SA64POS_FP(align_dst, p_dst); // finalize the stream
+
+  //Remainder Loop
+  for(i=0; i < (N & 3); i++)
+  {
+    ae_int32x2 j1, j2;
+    ae_int32x2 wj1;
+    ae_int32x2 wout1;
+    AE_L32_IP(wout1, (ae_int32 *)p_src1, sizeof(WORD32));
+    j1 = (WORD32) *(p_src2 + i);
+    j2 = (WORD32) *(p_src3 + i);
+    wj1 = AE_ADD32(j1, j2);
+    wout1 = AE_ADD32(wout1, wj1);
+    AE_S32_L_IP(wout1, (ae_int32 *)p_dst, sizeof(WORD32));
+  }
+}
+
+static void vecmean16_inpx2(const ae_int32x2 *p_src1, const WORD16* p_src2, ae_int32x2 *p_dst, int N){
+  ae_int32x2 ONE32 = AE_MOVDA32(1);
+  ae_valign align_src1, align_dst;
+  ae_valign align_src2;
+  align_src1 = AE_LA64_PP(p_src1);
+  align_src2 = AE_LA64_PP(p_src2);
+  align_dst = AE_ZALIGN64();
+
+  int i = 0;
+  for(i=0; i < (N >> 2); i++)
+  {
+    ae_int16x4 j1;
+    ae_int32x2 j1_32_h, j1_32_l;
+    ae_int32x2 wout1, wout2;
+    AE_LA32X2_IP(wout1, align_src1, p_src1);
+    AE_LA32X2_IP(wout2, align_src1, p_src1);
+
+    AE_LA16X4_IP(j1, align_src2, (ae_int16x4 *)p_src2);
+
+    j1_32_h = AE_SEXT32X2D16_32(j1);
+    j1_32_l = AE_SEXT32X2D16_10(j1);
+
+    AE_MULAP32X2(wout1, j1_32_h, ONE32);
+    AE_MULAP32X2(wout2, j1_32_l, ONE32);
+
+    AE_SA32X2_IP(wout1, align_dst, p_dst);
+    AE_SA32X2_IP(wout2, align_dst, p_dst);
+  }
+  AE_SA64POS_FP(align_dst, p_dst); // finalize the stream
+
+  //Remainder Loop
+  for(i=0; i < (N & 3); i++)
+  {
+    ae_int32x2 j1;
+    ae_int32x2 wout1;
+    AE_L32_IP(wout1, (ae_int32 *)p_src1, sizeof(WORD32));
+    j1 = (WORD32) *(p_src2 + i);
+    wout1 = AE_ADD32(wout1, j1);
+    AE_S32_L_IP(wout1, (ae_int32 *)p_dst, sizeof(WORD32));
+  }
+}
+
+static void vecmean32_inpx3(const ae_int32x2* p_src1, const ae_int32x2* p_wsrc2, const ae_int32x2* p_wsrc3, ae_int32x2 *p_dst, int N){
+  ae_valign align_src1, align_src2, align_src3, align_dst;
+  align_src1 = AE_LA64_PP(p_src1);
+  align_src2 = AE_LA64_PP(p_wsrc2);
+  align_src3 = AE_LA64_PP(p_wsrc3);
+  align_dst = AE_ZALIGN64();
+
+  int i = 0;
+  for(i=0; i < (N >> 2); i++)
+  {
+    ae_int32x2 j1, j2, j3, j4;
+    ae_int32x2 wj1, wj2;
+    ae_int32x2 wout1, wout2;
+    AE_LA32X2_IP(wout1, align_src1, p_src1);
+    AE_LA32X2_IP(wout2, align_src1, p_src1);
+    AE_LA32X2_IP(j1, align_src2, p_wsrc2);
+    AE_LA32X2_IP(j2, align_src3, p_wsrc3);
+    AE_LA32X2_IP(j3, align_src2, p_wsrc2);
+    AE_LA32X2_IP(j4, align_src3, p_wsrc3);
+    wj1 = AE_ADD32S(j1, j2);
+    wj2 = AE_ADD32S(j3, j4);
+    wout1 = AE_ADD32S(wout1, wj1);
+    wout2 = AE_ADD32S(wout2, wj2);
+    AE_SA32X2_IP(wout1, align_dst, p_dst);
+    AE_SA32X2_IP(wout2, align_dst, p_dst);
+  }
+  AE_SA64POS_FP(align_dst, p_dst); // finalize the stream
+
+  //Remainder Loop
+  for(i=0; i < (N & 3); i++)
+  {
+    ae_int32x2 j1, j2;
+    ae_int32x2 wj1;
+    ae_int32x2 wout1;
+    AE_L32_IP(wout1, (ae_int32 *)p_src1, 4);
+    AE_L32_IP(j1, (ae_int32 *)p_wsrc2, 4);
+    AE_L32_IP(j2, (ae_int32 *)p_wsrc3, 4);
+    wj1 = AE_ADD32S(j1, j2);
+    wout1 = AE_ADD32S(wout1, wj1);
+    AE_S32_L_IP(wout1, (ae_int32 *)p_dst, sizeof(WORD32));
+  }
+}
+
+static void vecmean32_inpx2(const ae_int32x2* p_src1, const ae_int32x2* p_wsrc2, ae_int32x2 *p_dst, int N){
+  ae_valign align_src1, align_src2, align_dst;
+  align_src1 = AE_LA64_PP(p_src1);
+  align_src2 = AE_LA64_PP(p_wsrc2);
+  align_dst = AE_ZALIGN64();
+
+  int i = 0;
+  for(i=0; i < (N >> 2); i++)
+  {
+    ae_int32x2 j1, j2;
+    ae_int32x2 wout1, wout2;
+    AE_LA32X2_IP(wout1, align_src1, p_src1);
+    AE_LA32X2_IP(wout2, align_src1, p_src1);
+    AE_LA32X2_IP(j1, align_src2, p_wsrc2);
+    AE_LA32X2_IP(j2, align_src2, p_wsrc2);
+    wout1 = AE_ADD32S(wout1, j1);
+    wout2 = AE_ADD32S(wout2, j2);
+    AE_SA32X2_IP(wout1, align_dst, p_dst);
+    AE_SA32X2_IP(wout2, align_dst, p_dst);
+  }
+  AE_SA64POS_FP(align_dst, p_dst); // finalize the stream
+
+  //Remainder Loop
+  for(i=0; i < (N & 3); i++)
+  {
+    ae_int32x2 j1;
+    ae_int32x2 wout1;
+    AE_L32_IP(wout1, (ae_int32 *)p_src1, 4);
+    AE_L32_IP(j1, (ae_int32 *)p_wsrc2, 4);
+    wout1 = AE_ADD32S(wout1, j1);
+    AE_S32_L_IP(wout1, (ae_int32 *)p_dst, sizeof(WORD32));
+  }
+}
+
+static inline void xa_nn_reduce_sum_4D_asym16s_asym16s(const WORD16 * __restrict__ p_inp
+                                                       ,const WORD32 *const p_4D_inp_shape
+                                                       ,const WORD32 * __restrict__ p_axis_data
+                                                       ,WORD32 num_inp_dims
+                                                       ,WORD32 num_axis_dims
+                                                       ,pVOID p_scratch_in)
+{
+  WORD16 *p_in = (WORD16 *)(p_inp);
+  WORD32 *p_scratch = (WORD32 *)(p_scratch_in);
+
+  int temp_inp_n = p_4D_inp_shape[0];
+  int temp_inp_h = p_4D_inp_shape[1];
+  int temp_inp_w = p_4D_inp_shape[2];
+  int temp_inp_c = p_4D_inp_shape[3];
+
+  int itr_axis = 0, itr_n = 0, itr_h = 0, itr_w = 0, itr_c = 0;
+  WORD16 *p_src2, *p_src3;
+  ae_int32x2 *p_src1;
+  ae_int32x2 * p_dst;
+  ae_valign align_dst;
+  ae_valign align_src2;
+  align_dst = AE_ZALIGN64();
+
+  int axis_dims_count = num_axis_dims;
+  if(axis_dims_count)
+  {
+    switch(p_axis_data[itr_axis])
+    {
+      case 0: {
+        int plane_size = temp_inp_h * temp_inp_w * temp_inp_c;
+        for(itr_n=0; itr_n < (temp_inp_n & ~(2 - 1)); itr_n += 2)
+        {
+          p_src1 = (ae_int32x2 *)(p_scratch);
+          p_src2 = p_in + itr_n * plane_size;
+          p_src3 = p_in + (itr_n + 1) * plane_size;
+          p_dst  = (ae_int32x2 *)(p_scratch);
+          vecmean16_inpx3(p_src1, p_src2, p_src3, p_dst, plane_size);
+        }
+
+        if(temp_inp_n & 1)
+        {
+          p_src1 = (ae_int32x2 *)(p_scratch);
+          p_src2 = (p_in + itr_n * plane_size);
+          p_dst  = (ae_int32x2 *)(p_scratch);
+          vecmean16_inpx2(p_src1, p_src2, p_dst, plane_size);
+        }
+        temp_inp_n = 1;
+        }break;
+      case 1: {
+        int plane_size = temp_inp_h * temp_inp_w * temp_inp_c;
+        int wc_plane_size = temp_inp_w * temp_inp_c;
+        for(itr_n=0; itr_n < (temp_inp_n); itr_n++)
+        {
+          p_src1 = (ae_int32x2 *)(p_scratch + (itr_n * wc_plane_size));
+          for(itr_h=0; itr_h < (temp_inp_h & ~(2 - 1)); itr_h += 2)
+          {
+            p_src2 = p_in + (itr_n * plane_size) + (itr_h * wc_plane_size);
+            p_src3 = p_in + (itr_n * plane_size) + ((itr_h + 1) * wc_plane_size);
+            p_dst = (ae_int32x2 *)(p_scratch + (itr_n * wc_plane_size));
+            vecmean16_inpx3(p_src1, p_src2, p_src3, p_dst, wc_plane_size);
+            p_src1 = (ae_int32x2 *)(p_scratch + (itr_n * wc_plane_size));
+          }
+
+          if(temp_inp_h & 1)
+          {
+            p_src2 = p_in + (itr_n * plane_size) + (itr_h * wc_plane_size);
+            p_dst = (ae_int32x2 *)(p_scratch + (itr_n * wc_plane_size));
+            vecmean16_inpx2(p_src1, p_src2, p_dst, wc_plane_size);
+          }
+        }
+        temp_inp_h = 1;
+        }break;
+      case 2:{
+        int plane_size = temp_inp_h * temp_inp_w * temp_inp_c;
+        int wc_plane_size = temp_inp_w * temp_inp_c;
+        int hc_plane_size = temp_inp_h * temp_inp_c;
+        for(itr_n=0; itr_n < (temp_inp_n); itr_n++)
+        {
+          for(itr_h=0; itr_h < (temp_inp_h); itr_h++)
+          {
+            p_src1 = (ae_int32x2 *)(p_scratch + (((itr_n * hc_plane_size) + itr_h * temp_inp_c)));
+            for(itr_w=0; itr_w < (temp_inp_w & ~(2 - 1)); itr_w += 2)
+            {
+              p_src2 = p_in + (itr_n * plane_size) + (itr_h * wc_plane_size) + (itr_w * temp_inp_c);
+              p_src3 = p_in + (itr_n * plane_size) + (itr_h * wc_plane_size) + ((itr_w + 1) * temp_inp_c);
+              p_dst = (ae_int32x2 *)(p_scratch + (itr_n * hc_plane_size) + itr_h * temp_inp_c);
+              vecmean16_inpx3(p_src1, p_src2, p_src3, p_dst, temp_inp_c);
+              p_src1 = (ae_int32x2 *)(p_scratch + (itr_n * hc_plane_size) + (itr_h * temp_inp_c));
+            }
+
+            if(temp_inp_w & 1)
+            {
+              p_src2 = p_in + (itr_n * plane_size) + (itr_h * wc_plane_size) + (itr_w * temp_inp_c);
+              p_dst = (ae_int32x2 *)(p_scratch + (itr_n * hc_plane_size) + itr_h * temp_inp_c);
+              vecmean16_inpx2(p_src1, p_src2, p_dst, temp_inp_c);
+            }
+          }
+        }
+        temp_inp_w = 1;
+        }break;
+      case 3: {
+        int plane_size = temp_inp_h * temp_inp_w * temp_inp_c;
+        int wc_plane_size = temp_inp_w * temp_inp_c;
+        int hw_plane_size = temp_inp_h * temp_inp_w;
+        int rem_c = (temp_inp_c & 7);
+
+        for(itr_n=0; itr_n < (temp_inp_n); itr_n++)
+        {
+          for(itr_h=0; itr_h < (temp_inp_h); itr_h++)
+          {
+            for(itr_w=0; itr_w < (temp_inp_w); itr_w++)
+            {
+              p_src1 = (ae_int32x2 *)(p_scratch + (((itr_n * hw_plane_size) + (itr_h * temp_inp_w) + itr_w)));
+              p_src2 = p_in + (itr_n * plane_size) + (itr_h * wc_plane_size) + (itr_w * temp_inp_c);
+              p_dst = (ae_int32x2 *)(p_scratch + (itr_n * hw_plane_size) + (itr_h * temp_inp_w) + itr_w);
+              align_src2 = AE_LA64_PP(p_src2);
+              ae_int16x4 one_16x4 = AE_MOVDA16(1);
+              for(itr_c=0; itr_c < (temp_inp_c >> 3); itr_c++)
+              {
+                ae_int16x4 j1, j2;
+                ae_int32x2 i1, i2;
+                ae_int64 out1, out2;
+                i1 = AE_L32_I((ae_int32 *)p_src1, 0);
+                AE_LA16X4_IP(j1, align_src2, (ae_int16x4 *)p_src2);
+                AE_LA16X4_IP(j2, align_src2, (ae_int16x4 *)p_src2);
+                out1 = AE_MULZAAAAQ16(j1, one_16x4);
+                out2 = AE_MULZAAAAQ16(j2, one_16x4);
+                i2 = AE_ADD32S(AE_MOVDA32(AE_MOVINT32_FROMINT64(out1)),AE_MOVDA32(AE_MOVINT32_FROMINT64(out2)));
+                i1 = AE_ADD32S(i1, i2);
+                AE_S32_L_I(i1, (ae_int32 *)p_dst, 0);
+                p_src1 = p_dst;
+              }
+              //Remainder Loop
+              for(itr_c=0; itr_c < rem_c ; itr_c++)
+              {
+                WORD16 j1;
+                ae_int32x2 i1;
+                i1 = AE_L32_I((ae_int32 *)p_src1, 0);
+                j1 = (WORD32) *(WORD16 *)p_src2;
+                p_src2++;
+                i1 = AE_ADD32S(i1, AE_MOVDA32(j1));
+                AE_S32_L_I(i1, (ae_int32 *)p_dst, 0);
+              }
+            }
+          }
+        }
+        temp_inp_c = 1;
+        }break;
+      default:
+        break;
+    }
+
+    axis_dims_count--;
+    itr_axis++;
+  }
+
+  while(axis_dims_count)
+  {
+    ae_valign align_src;
+    WORD32 *p_scr_in =(WORD32 *)p_scratch;
+    ae_int32x2 *p_wsrc2, *p_wsrc3;
+    switch(p_axis_data[itr_axis])
+    {
+      case 0: {
+        int plane_size = temp_inp_h * temp_inp_w * temp_inp_c;
+        for(itr_n=1; itr_n < ((temp_inp_n -1) & ~(2 - 1)); itr_n += 2)
+        {
+          p_src1 = (ae_int32x2 *)(p_scratch);
+          p_wsrc2 = (ae_int32x2 *)(p_scr_in + itr_n * plane_size);
+          p_wsrc3 = (ae_int32x2 *)(p_scr_in + (itr_n + 1) * plane_size);
+          p_dst  = (ae_int32x2 *)(p_scratch);
+          vecmean32_inpx3(p_src1, p_wsrc2, p_wsrc3, p_dst, plane_size);
+        }
+
+        if((temp_inp_n - 1) & 1)
+        {
+          p_src1 = (ae_int32x2 *)(p_scratch);
+          p_wsrc2 = (ae_int32x2 *)(p_scr_in + itr_n * plane_size);
+          p_dst  = (ae_int32x2 *)(p_scratch);
+          vecmean32_inpx2(p_src1, p_wsrc2, p_dst, plane_size);
+        }
+        temp_inp_n = 1;
+        }break;
+      case 1: {
+        int plane_size = temp_inp_h * temp_inp_w * temp_inp_c;
+        int wc_plane_size = temp_inp_w * temp_inp_c;
+        for(itr_n=0; itr_n < (temp_inp_n); itr_n++)
+        {
+          p_src1 = (ae_int32x2 *)(p_scratch + + (itr_n * plane_size));
+          for(itr_h = 1; itr_h < ((temp_inp_h - 1) & ~(2 - 1)); itr_h += 2)
+          {
+            p_wsrc2 = (ae_int32x2 *)(p_scr_in + (itr_n * plane_size) + (itr_h * wc_plane_size));
+            p_wsrc3 = (ae_int32x2 *)(p_scr_in + (itr_n * plane_size) + ((itr_h + 1) * wc_plane_size));
+            p_dst = (ae_int32x2 *)(p_scratch + (itr_n * wc_plane_size));
+            vecmean32_inpx3(p_src1, p_wsrc2, p_wsrc3, p_dst, wc_plane_size);
+            p_src1 = (ae_int32x2 *)(p_scratch + (itr_n * wc_plane_size));
+          }
+
+          if((temp_inp_h - 1) & 1)
+          {
+            p_wsrc2 = (ae_int32x2 *)(p_scr_in + (itr_n * plane_size) + (itr_h * wc_plane_size));
+            p_dst = (ae_int32x2 *)(p_scratch + (itr_n * wc_plane_size));
+            vecmean32_inpx2(p_src1, p_wsrc2, p_dst, plane_size);
+          }
+        }
+        temp_inp_h = 1;
+        }break;
+      case 2:{
+        int plane_size = temp_inp_h * temp_inp_w * temp_inp_c;
+        int wc_plane_size = temp_inp_w * temp_inp_c;
+        int hc_plane_size = temp_inp_h * temp_inp_c;
+        for(itr_n=0; itr_n < (temp_inp_n); itr_n++)
+        {
+          for(itr_h=0; itr_h < (temp_inp_h); itr_h++)
+          {
+            p_src1 = (ae_int32x2 *)(p_scratch + ((itr_n * plane_size) + (itr_h * wc_plane_size)));
+            for(itr_w = 1; itr_w < ((temp_inp_w - 1) & ~(2 - 1)); itr_w += 2)
+            {
+              p_wsrc2 = (ae_int32x2 *)(p_scr_in + (itr_n * plane_size) + (itr_h * wc_plane_size) + (itr_w * temp_inp_c));
+              p_wsrc3 = (ae_int32x2 *)(p_scr_in + (itr_n * plane_size) + (itr_h * wc_plane_size) + ((itr_w + 1) * temp_inp_c));
+              p_dst = (ae_int32x2 *)(p_scratch + (itr_n * hc_plane_size) + itr_h * temp_inp_c);
+              vecmean32_inpx3(p_src1, p_wsrc2, p_wsrc3, p_dst, temp_inp_c);
+              p_src1 = (ae_int32x2 *)(p_scratch + (itr_n * hc_plane_size) + (itr_h * temp_inp_c));
+            }
+
+            if((temp_inp_w - 1) & 1)
+            {
+              p_wsrc2 = (ae_int32x2 *)(p_scr_in + (itr_n * plane_size) + (itr_h * wc_plane_size) + (itr_w * temp_inp_c));
+              p_dst = (ae_int32x2 *)(p_scratch + (itr_n * hc_plane_size) + itr_h * temp_inp_c);
+              vecmean32_inpx2(p_src1, p_wsrc2, p_dst, temp_inp_c);
+            }
+          }
+        }
+        temp_inp_w = 1;
+        }break;
+      case 3: {
+        int plane_size = temp_inp_h * temp_inp_w * temp_inp_c;
+        int wc_plane_size = temp_inp_w * temp_inp_c;
+        int hw_plane_size = temp_inp_h * temp_inp_w;
+        int rem_c = ((temp_inp_c) & 3);
+        for(itr_n=0; itr_n < (temp_inp_n); itr_n++)
+        {
+          for(itr_h=0; itr_h < (temp_inp_h); itr_h++)
+          {
+            for(itr_w=0; itr_w < (temp_inp_w); itr_w++)
+            {
+              p_wsrc2 = (ae_int32x2 *)(p_scr_in + (itr_n * plane_size) + (itr_h * wc_plane_size) + (itr_w * temp_inp_c));
+              p_dst = (ae_int32x2 *)(p_scratch + (itr_n * hw_plane_size) + (itr_h * temp_inp_w) + itr_w);
+              align_src = AE_LA64_PP(p_wsrc2);
+              ae_int32x2 i1 = AE_ZERO32();
+              for(itr_c = 0; itr_c < (temp_inp_c >> 2); itr_c++)
+              {
+                ae_int32x2 j1, j2;
+                ae_int32 out1, out2;
+                AE_LA32X2_IP(j1, align_src, p_wsrc2);
+                AE_LA32X2_IP(j2, align_src, p_wsrc2);
+                out1 = AE_INT32X2_RADD(j1);
+                out2 = AE_INT32X2_RADD(j2);
+                i1 = AE_ADD32S(i1, AE_MOVDA32(out1));
+                i1 = AE_ADD32S(i1, AE_MOVDA32(out2));
+              }
+
+              //Remainder Loop
+              for(itr_c=0; itr_c < rem_c; itr_c++)
+              {
+                ae_int32x2 j1;
+                AE_L32_IP(j1, (ae_int32 *)p_wsrc2, sizeof(WORD32));
+                i1 = AE_ADD32S(i1, j1);
+              }
+              AE_S32_L_I(i1, (ae_int32 *)p_dst, 0);
+            }
+          }
+        }
+        temp_inp_c = 1;
+        }break;
+      default:
+        break;
+    }
+    axis_dims_count--;
+    itr_axis++;
+  }
+}
+
+WORD32 xa_nn_reduce_mean_4D_asym16s_asym16s(WORD16 * __restrict__ p_out
+                                            ,const WORD32 *const p_out_shape
+                                            ,const WORD16 * __restrict__ p_inp
+                                            ,const WORD32 *const p_inp_shape
+                                            ,const WORD32 * __restrict__ p_axis
+                                            ,WORD32 num_out_dims
+                                            ,WORD32 num_inp_dims
+                                            ,WORD32 num_axis_dims
+                                            ,WORD32 inp_zero_bias
+                                            ,WORD32 out_multiplier
+                                            ,WORD32 out_shift
+                                            ,WORD32 out_zero_bias
+                                            ,void * __restrict__ p_scratch_in)
+{
+  /* NULL pointer checks */
+  XA_NNLIB_ARG_CHK_PTR(p_out, -1);
+  XA_NNLIB_ARG_CHK_PTR(p_inp, -1);
+  XA_NNLIB_ARG_CHK_PTR(p_axis, -1);
+  XA_NNLIB_ARG_CHK_PTR(p_out_shape, -1);
+  XA_NNLIB_ARG_CHK_PTR(p_inp_shape, -1);
+
+  /* Invalid input checks */
+  XA_NNLIB_ARG_CHK_COND(((num_inp_dims <= 0) || (num_inp_dims > 4)), -1);
+  XA_NNLIB_ARG_CHK_COND(((num_out_dims <= 0) || (num_out_dims > 4)), -1);
+  XA_NNLIB_ARG_CHK_COND(((num_axis_dims < 0) || (num_axis_dims > 4)), -1);
+  XA_NNLIB_ARG_CHK_COND((inp_zero_bias < -32768 || inp_zero_bias > 32767), -1);
+  XA_NNLIB_ARG_CHK_COND((out_zero_bias < -32768 || out_zero_bias > 32767), -1);
+  XA_NNLIB_ARG_CHK_COND((out_shift < -31 || out_shift > 31), -1);
+  XA_NNLIB_ARG_CHK_COND((out_multiplier < 0), -1);
+
+  extern const unsigned int inv_256_tbl[1025];
+  ae_int32x2 inv_mult;
+  int axis_itr = 0, inp_itr = 0, out_itr = 0;
+  int num_elm_in_axis = 1;
+  int current, past = -1;
+  for(axis_itr=0; axis_itr < num_axis_dims; axis_itr++)
+  {
+    current = p_axis[axis_itr];
+    XA_NNLIB_ARG_CHK_COND(((current < 0) || (current > (num_inp_dims - 1))), -1);
+    XA_NNLIB_ARG_CHK_COND((p_inp_shape[current] > 1024), -1);
+
+    /* Avoid calculation in case of repeated axis dims*/
+    if(current != past)
+    {
+      num_elm_in_axis *= p_inp_shape[current];
+      past = current;
+    }
+  }
+  if(num_elm_in_axis <= 1024)
+  {
+    inv_mult = AE_MOVDA32(inv_256_tbl[num_elm_in_axis]);
+  }
+  else
+  {
+    inv_mult = AE_MOVDA32(((0x80000000UL) / (unsigned)num_elm_in_axis));
+  }
+
+  for(inp_itr=0; inp_itr < num_inp_dims; inp_itr++)
+  {
+    XA_NNLIB_ARG_CHK_COND((p_inp_shape[inp_itr] <= 0), -1);
+  }
+
+  int out_length = 1;
+  for(out_itr=0; out_itr < num_out_dims; out_itr++)
+  {
+    XA_NNLIB_ARG_CHK_COND((p_out_shape[out_itr] <= 0), -1);
+    out_length *= p_out_shape[out_itr];
+  }
+
+  /* Pointer alignment checks */
+  XA_NNLIB_ARG_CHK_ALIGN(p_out, sizeof(WORD16), -1);
+  XA_NNLIB_ARG_CHK_ALIGN(p_inp, sizeof(WORD16), -1);
+  XA_NNLIB_ARG_CHK_ALIGN(p_axis, sizeof(WORD32), -1);
+  XA_NNLIB_ARG_CHK_ALIGN(p_out_shape, sizeof(WORD32), -1);
+  XA_NNLIB_ARG_CHK_ALIGN(p_inp_shape, sizeof(WORD32), -1);
+
+  int left_shift, right_shift;
+#if TFLITE_SINGLE_ROUNDING
+  left_shift = out_shift;
+  (void)right_shift;
+#else /* #if TFLITE_SINGLE_ROUNDING */
+  left_shift = out_shift < 0 ? 0 : out_shift;
+  right_shift = out_shift > 0 ? 0 : -out_shift;
+#endif /* #if TFLITE_SINGLE_ROUNDING */
+
+  WORD16 *p_in = (WORD16 *)(p_inp);
+  WORD32 *p_scratch = (WORD32 *)(ALIGN_PTR(p_scratch_in, ALIGNMENT_8));
+
+  // Changing order of axis data so that reduce max will be first computed
+  // across largest inp shape dim in axis. This is required to
+  // minimize the scratch usage.
+  int inp_length = 1, p_axis_data[4], inp_shape_max;
+  if(num_axis_dims)
+  {
+    inp_shape_max = p_inp_shape[p_axis[0]];
+    axis_itr = 1;
+    int max_axis_itr = 0;
+    int temp_p_axis_0 = p_axis[0];
+    for(axis_itr = 0; axis_itr < num_axis_dims; axis_itr++)
+    {
+      p_axis_data[axis_itr] = p_axis[axis_itr];
+    }
+    for(axis_itr = 1; axis_itr < num_axis_dims; axis_itr++)
+    {
+      if(p_inp_shape[p_axis[axis_itr]] > inp_shape_max)
+      {
+        inp_shape_max = p_inp_shape[p_axis[axis_itr]];
+        max_axis_itr = axis_itr;
+      }
+    }
+    p_axis_data[0] = p_axis_data[max_axis_itr];
+    p_axis_data[max_axis_itr] = temp_p_axis_0;
+
+    inp_itr = 0;
+    for(inp_itr=0; inp_itr < num_inp_dims; inp_itr++)
+    {
+      inp_length *= p_inp_shape[inp_itr];
+    }
+
+    memset(p_scratch, 0, ((inp_length / inp_shape_max) * sizeof(WORD32))); //TODO: Alternate approach for memset?
+  }
+
+  // Promoting lesser dim tensors to 4D tensors. Also modifying axis
+  // data accordingly.
+  int p_4D_inp_shape[4] = {1, 1, 1, 1};
+  int itr = num_inp_dims - 1;
+  int count = 3;
+  while(itr >= 0)
+  {
+    p_4D_inp_shape[count] = p_inp_shape[itr];
+    itr--;
+    count--;
+  }
+  for(itr = 0; itr < num_axis_dims; itr++)
+  {
+    p_axis_data[itr] = p_axis_data[itr] + (4 - num_inp_dims);
+  }
+  ae_valign align_out = AE_ZALIGN64();
+
+  if(num_axis_dims)
+  {
+    if(num_elm_in_axis > 1)
+    {
+      xa_nn_reduce_sum_4D_asym16s_asym16s(p_in,
+                                        p_4D_inp_shape,
+                                        p_axis_data,
+                                        num_inp_dims,
+                                        num_axis_dims,
+                                        p_scratch);
+
+      xtbool same_quant = (inp_zero_bias == out_zero_bias) && (out_multiplier == 0x40000000) && (out_shift == 1);
+
+      itr = 0;
+      ae_int32x2 *p_src1 = (ae_int32x2 *)(p_scratch);
+
+      if(same_quant)
+      {
+        for(itr = 0; itr < (out_length >> 3); itr++)
+        {
+          ae_int32x2 wout1, wout2, wout3, wout4;
+          ae_int32x2 temp1, temp2, temp3, temp4;
+
+          wout2 = AE_L32X2_I(p_src1, 8);
+          wout3 = AE_L32X2_I(p_src1, 16);
+          wout4 = AE_L32X2_I(p_src1, 24);
+          AE_L32X2_IP(wout1, p_src1, 32);
+          temp1 = AE_MULFP32X2RS(inv_mult, wout1);
+          temp2 = AE_MULFP32X2RS(inv_mult, wout2);
+          temp3 = AE_MULFP32X2RS(inv_mult, wout3);
+          temp4 = AE_MULFP32X2RS(inv_mult, wout4);
+
+          temp1 = AE_MIN32(AE_MOVDA32(32767), AE_MAX32(temp1, AE_MOVDA32(-32768)));
+          temp2 = AE_MIN32(AE_MOVDA32(32767), AE_MAX32(temp2, AE_MOVDA32(-32768)));
+          temp3 = AE_MIN32(AE_MOVDA32(32767), AE_MAX32(temp3, AE_MOVDA32(-32768)));
+          temp4 = AE_MIN32(AE_MOVDA32(32767), AE_MAX32(temp4, AE_MOVDA32(-32768)));
+          ae_int16x4 out;
+          out = AE_SEL16_6420(AE_MOVF16X4_FROMF32X2(temp1), AE_MOVF16X4_FROMF32X2(temp2));
+          AE_SA16X4_IP(out, align_out, (ae_int16x4 *)p_out);
+          out = AE_SEL16_6420(AE_MOVF16X4_FROMF32X2(temp3), AE_MOVF16X4_FROMF32X2(temp4));
+          AE_SA16X4_IP(out, align_out, (ae_int16x4 *)p_out);
+        }
+        AE_SA64POS_FP(align_out, p_out);
+
+        for(itr = 0; itr < (out_length & 7); itr++)
+        {
+          ae_int32x2 wout1;
+          ae_int32x2 temp1;
+          AE_L32_IP(wout1, (ae_int32 *)p_src1, 4);
+          temp1 = AE_MULFP32X2RS(inv_mult, wout1);
+          temp1 = AE_MIN32(AE_MOVDA32(32767), AE_MAX32(temp1, AE_MOVDA32(-32768)));
+          *p_out++ = (WORD16) AE_MOVAD32_H(temp1);
+        }
+      }
+      else
+      {
+        WORD64 tot_bias = (WORD64)(-inp_zero_bias) * (WORD64)(num_elm_in_axis);
+        tot_bias = AE_MIN64(AE_MOVDA32(2147483647), AE_MAX64(tot_bias, AE_MOVDA32(-2147483648)));
+        ae_int32x2 total_bias = AE_MOVDA32(AE_MOVINT32_FROMINT64(tot_bias));
+        for(itr = 0; itr < (out_length >> 3); itr++)
+        {
+          ae_int32x2 wout1, wout2, wout3, wout4;
+          ae_int32x2 d0_out32, d1_out32, d2_out32, d3_out32;
+
+          wout2 = AE_L32X2_I(p_src1, 8);
+          wout3 = AE_L32X2_I(p_src1, 16);
+          wout4 = AE_L32X2_I(p_src1, 24);
+          AE_L32X2_IP(wout1, p_src1, 32);
+          wout1 = AE_ADD32S(wout1, total_bias);
+          wout2 = AE_ADD32S(wout2, total_bias);
+          wout3 = AE_ADD32S(wout3, total_bias);
+          wout4 = AE_ADD32S(wout4, total_bias);
+
+          MPY_BY_QUANT_MULT_SLS_X2_OUT32(d0_out32, wout1, out_multiplier, left_shift, right_shift);
+          d0_out32 = AE_MULFP32X2RS(inv_mult, d0_out32);
+          d0_out32 = AE_ADD32S(AE_MOVDA32(out_zero_bias), d0_out32);
+          MPY_BY_QUANT_MULT_SLS_X2_OUT32(d1_out32, wout2, out_multiplier, left_shift, right_shift);
+          d1_out32 = AE_MULFP32X2RS(inv_mult, d1_out32);
+          d1_out32 = AE_ADD32S(AE_MOVDA32(out_zero_bias), d1_out32);
+          MPY_BY_QUANT_MULT_SLS_X2_OUT32(d2_out32, wout3, out_multiplier, left_shift, right_shift);
+          d2_out32 = AE_MULFP32X2RS(inv_mult, d2_out32);
+          d2_out32 = AE_ADD32S(AE_MOVDA32(out_zero_bias), d2_out32);
+          MPY_BY_QUANT_MULT_SLS_X2_OUT32(d3_out32, wout4, out_multiplier, left_shift, right_shift);
+          d3_out32 = AE_MULFP32X2RS(inv_mult, d3_out32);
+          d3_out32 = AE_ADD32S(AE_MOVDA32(out_zero_bias), d3_out32);
+
+          d0_out32 = AE_MIN32(AE_MOVDA32(32767), AE_MAX32(d0_out32, AE_MOVDA32(-32768)));
+          d1_out32 = AE_MIN32(AE_MOVDA32(32767), AE_MAX32(d1_out32, AE_MOVDA32(-32768)));
+          d2_out32 = AE_MIN32(AE_MOVDA32(32767), AE_MAX32(d2_out32, AE_MOVDA32(-32768)));
+          d3_out32 = AE_MIN32(AE_MOVDA32(32767), AE_MAX32(d3_out32, AE_MOVDA32(-32768)));
+
+          ae_int16x4 out;
+          out = AE_SEL16_6420(AE_MOVF16X4_FROMF32X2(d0_out32), AE_MOVF16X4_FROMF32X2(d1_out32));
+          AE_SA16X4_IP(out, align_out, (ae_int16x4 *)p_out);
+          out = AE_SEL16_6420(AE_MOVF16X4_FROMF32X2(d2_out32), AE_MOVF16X4_FROMF32X2(d3_out32));
+          AE_SA16X4_IP(out, align_out, (ae_int16x4 *)p_out);
+
+        }
+        AE_SA64POS_FP(align_out, p_out);
+
+        for(itr = 0; itr < (out_length & 7); itr++)
+        {
+          ae_int32x2 wout1;
+          ae_int32x2 d0_out32;
+
+          AE_L32_IP(wout1, (ae_int32 *)p_src1, 4);
+          wout1 = AE_ADD32S(wout1, total_bias);
+
+          MPY_BY_QUANT_MULT_SLS_X2_OUT32(d0_out32, wout1, out_multiplier, left_shift, right_shift);
+          d0_out32 = AE_MULFP32X2RS(inv_mult, d0_out32);
+          d0_out32 = AE_ADD32S(AE_MOVDA32(out_zero_bias), d0_out32);
+
+          d0_out32 = AE_MIN32(AE_MOVDA32(32767), AE_MAX32(d0_out32, AE_MOVDA32(-32768)));
+          *p_out++ = (WORD16) AE_MOVAD32_H(d0_out32);
+        }
+      }
+    }
+    else
+    {
+      xtbool same_quant = (inp_zero_bias == out_zero_bias) && (out_multiplier == 0x40000000) && (out_shift == 1);
+
+      itr = 0;
+      ae_valign align_inp = AE_LA64_PP(p_in);
+
+      if(same_quant)
+      {
+        memcpy(p_out, p_inp, inp_length * sizeof(WORD16));
+      }
+      else
+      {
+#pragma no_unroll
+        for(itr = 0; itr < (out_length >> 2); itr++)
+        {
+          ae_int16x4 wout1;
+          ae_int32x2 d0_out32, d1_out32;
+          ae_int32x2 temp1, temp2;
+          temp1 = AE_MOVDA32(-inp_zero_bias);
+          temp2 = AE_MOVDA32(-inp_zero_bias);
+          AE_LA16X4_IP(wout1, align_inp, (ae_int16x4 *)p_in);
+          AE_MULA16X4(temp1, temp2, wout1, AE_MOVDA16(1));
+
+          MPY_BY_QUANT_MULT_SLS_X2_OUT32(temp1, temp1, out_multiplier, left_shift, right_shift);
+          d0_out32 = AE_ADD32S(AE_MOVDA32(out_zero_bias), temp1);
+          MPY_BY_QUANT_MULT_SLS_X2_OUT32(temp2, temp2, out_multiplier, left_shift, right_shift);
+          d1_out32 = AE_ADD32S(AE_MOVDA32(out_zero_bias), temp2);
+
+          d0_out32 = AE_MIN32(AE_MOVDA32(32767), AE_MAX32(d0_out32, AE_MOVDA32(-32768)));
+          d1_out32 = AE_MIN32(AE_MOVDA32(32767), AE_MAX32(d1_out32, AE_MOVDA32(-32768)));
+
+          ae_int16x4 out = AE_SEL16_6420(AE_MOVF16X4_FROMF32X2(d0_out32), AE_MOVF16X4_FROMF32X2(d1_out32));
+          AE_SA16X4_IP(out, align_out, (ae_int16x4 *)p_out);
+        }
+        AE_SA64POS_FP(align_out, p_out);
+
+        //Remainder Loop
+        for(itr = 0; itr < (out_length & 3); itr++)
+        {
+          WORD16 wout1;
+          ae_int32x2 d0_out32;
+          ae_int32x2 temp1, temp2;
+          temp1 = AE_MOVDA32(-inp_zero_bias);
+          temp2 = AE_MOVDA32(-inp_zero_bias);
+          wout1 = (WORD16) *(p_in + itr);
+          wout1 = AE_MOVDA16(wout1);
+          AE_MULA16X4(temp1, temp2, wout1, AE_MOVDA16(1));
+          MPY_BY_QUANT_MULT_SLS_X2_OUT32(temp1, temp1, out_multiplier, left_shift, right_shift);
+          d0_out32 = AE_ADD32S(AE_MOVDA32(out_zero_bias), temp1);
+          d0_out32 = AE_MIN32(AE_MOVDA32(32767), AE_MAX32(d0_out32, AE_MOVDA32(-32768)));
+          *p_out++ = (WORD16) AE_MOVAD32_H(d0_out32);
+        }
+      }
+    }
+  }
+  else
+  {
+    memcpy(p_out, p_inp, inp_length * sizeof(WORD16));
+  }
+
+  return 0;
+}
diff --git a/algo/kernels/basic/hifi4/xa_nn_reduce_asym8s_asym8s.c b/algo/kernels/basic/hifi4/xa_nn_reduce_asym8s_asym8s.c
index cffe491..947d760 100644
--- a/algo/kernels/basic/hifi4/xa_nn_reduce_asym8s_asym8s.c
+++ b/algo/kernels/basic/hifi4/xa_nn_reduce_asym8s_asym8s.c
@@ -69,20 +69,26 @@ WORD32 xa_nn_reduce_getsize_nhwc(WORD32 inp_precision
         inp_length *= p_inp_shape[inp_itr];
       }
 
-      if((inp_precision == -4) && (reduce_ops == REDUCE_MAX)) /*For Reduce Max*/
+      if(reduce_ops == REDUCE_MAX) /*For Reduce Max*/
       {
-        scratch_bytewidth = sizeof(WORD8);
+        if(inp_precision == -4){
+          scratch_bytewidth = sizeof(WORD8);
+        }
+        else if(inp_precision == -7){
+          scratch_bytewidth = sizeof(WORD16);
+        }
+
         if(inp_shape_max)
         {
-          return (ALIGNED_SIZE(((inp_length / inp_shape_max) * scratch_bytewidth), ALIGNMENT_8) + (BUS_WIDTH_8));
+          return (ALIGNED_SIZE(((inp_length / inp_shape_max) * scratch_bytewidth) + (BUS_WIDTH_8), ALIGNMENT_8));
         }
       }
-      else if((inp_precision == -4) && (reduce_ops == REDUCE_MEAN)) /*For Reduce Mean*/
+      else if(reduce_ops == REDUCE_MEAN) /*For Reduce Mean*/
       {
         scratch_bytewidth = sizeof(WORD32);
         if(inp_shape_max)
         {
-          return (ALIGNED_SIZE(((inp_length / inp_shape_max) * scratch_bytewidth), ALIGNMENT_8) + (BUS_WIDTH_8));
+          return (ALIGNED_SIZE(((inp_length / inp_shape_max) * scratch_bytewidth) + (BUS_WIDTH_8), ALIGNMENT_8));
         }
       }
     }
diff --git a/algo/kernels/cnn/hifi4/xa_nn_matXvec_sym8sxasym8s_asym8s_circ.c b/algo/kernels/cnn/hifi4/xa_nn_matXvec_sym8sxasym8s_asym8s_circ.c
index e9326f0..0f3aad6 100644
--- a/algo/kernels/cnn/hifi4/xa_nn_matXvec_sym8sxasym8s_asym8s_circ.c
+++ b/algo/kernels/cnn/hifi4/xa_nn_matXvec_sym8sxasym8s_asym8s_circ.c
@@ -1030,11 +1030,6 @@ WORD32 xa_nn_matXvec_sym8sxasym8s_asym8s_circ(
       int left_shift1 = p_out_shift[vec_itr+1];
       int left_shift2 = p_out_shift[vec_itr+2];
       int left_shift3 = p_out_shift[vec_itr+3];
-      /* Single rounding macro doesn't need two shifts so this is not used */
-      (void)right_shift0;
-      (void)right_shift1;
-      (void)right_shift2;
-      (void)right_shift3;
 #else /* #if TFLITE_SINGLE_ROUNDING */
       int left_shift0 = p_out_shift[vec_itr]<0?0:p_out_shift[vec_itr];
       int right_shift0 = p_out_shift[vec_itr]>0?0:-p_out_shift[vec_itr];
diff --git a/algo/kernels/cnn/hifi4/xa_nn_transpose_conv_circ_buf.c b/algo/kernels/cnn/hifi4/xa_nn_transpose_conv_circ_buf.c
index 673e9d0..a9c039b 100644
--- a/algo/kernels/cnn/hifi4/xa_nn_transpose_conv_circ_buf.c
+++ b/algo/kernels/cnn/hifi4/xa_nn_transpose_conv_circ_buf.c
@@ -63,6 +63,11 @@ WORD32 xa_nn_transpose_conv_getsize
             scratch_bytewidth = 8; /* 64b scratch */
             align_size = ALIGNMENT >> 1;
             break;
+        case -4: /* For asym8s */
+            input_size = sizeof(WORD8);
+            scratch_bytewidth = 4; /* 32b scratch */
+            align_size = ALIGNMENT >> 1;
+            break;
         case -1: /* For float32 */
             input_size = sizeof(FLOAT32);
             scratch_bytewidth = 8; /* 32bx2 scratch */
@@ -103,7 +108,7 @@ WORD32 xa_nn_transpose_conv_getsize
       }
       total_size += kernel_bytes + cir_buf_size_bytes; 
       total_size += BUS_WIDTH;
-      total_size = PADDED_SIZE(total_size, 8);
+      total_size = PADDED_SIZE(total_size, align_size);
     }
     else
     {
diff --git a/algo/kernels/cnn/hifi4/xa_nn_transpose_conv_f32.c b/algo/kernels/cnn/hifi4/xa_nn_transpose_conv_f32.c
index 3ba344e..494a527 100644
--- a/algo/kernels/cnn/hifi4/xa_nn_transpose_conv_f32.c
+++ b/algo/kernels/cnn/hifi4/xa_nn_transpose_conv_f32.c
@@ -564,7 +564,7 @@ static inline void transpose_conv2d_std_f32xf32(FLOAT32* output_data,
     idx_beg_inp_width_pad += 1;
 
     int kernelIdx;
-    for (int kIdx = 0; kIdx < rem_val_out_w; kIdx++)
+    for (int kIdx = 0; kIdx < rem_val_out_w; kIdx++, pad_w--)
     {
       WORD32 rem_val_out_h = (valid_out_h - pad_height) % stride_height;
       WORD32 is_pad_w = (pad_w > 0);
diff --git a/algo/kernels/cnn/hifi4/xa_nn_transpose_conv_sym8sxasym8s.c b/algo/kernels/cnn/hifi4/xa_nn_transpose_conv_sym8sxasym8s.c
new file mode 100644
index 0000000..7265607
--- /dev/null
+++ b/algo/kernels/cnn/hifi4/xa_nn_transpose_conv_sym8sxasym8s.c
@@ -0,0 +1,692 @@
+/*******************************************************************************
+* Copyright (c) 2018-2023 Cadence Design Systems, Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining
+* a copy of this software and associated documentation files (the
+* "Software"), to use this Software with Cadence processor cores only and
+* not with any other processors and platforms, subject to
+* the following conditions:
+*
+* The above copyright notice and this permission notice shall be included
+* in all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************************/
+#include "xa_nnlib_common.h"
+#include "xa_nnlib_common_macros.h"
+#include "xa_nn_transpose_conv_state.h"
+#include <string.h>
+
+static inline void tconv2d_sym8sxasym8s(WORD8* output_data,
+    const WORD8* input_data,
+    const WORD8* filter_data,
+    const WORD32* bias_data,
+    int stride_width, int stride_height,
+    int pad_width, int pad_height,
+    int input_depth, int output_depth,
+    int input_height, int input_width,
+    int filter_height, int filter_width,
+    int output_height, int output_width,
+    int num_elements,
+    int input_offset, int output_offset,
+    int *output_shift, int *output_multiplier,
+    int32_t* scratch_buffer)
+{
+  ae_int32 *pscratch = (ae_int32*)scratch_buffer;
+  memset(pscratch, 0, num_elements*sizeof(WORD32));
+
+  int stride1 = filter_height*filter_width*input_depth;
+  WORD8 *pinp;
+
+  /*
+   * Special case for input_depth multiple of 16
+   */
+  if(input_data && filter_data && scratch_buffer &&
+      (((unsigned int)input_data&0x3)==0) && (((unsigned int)filter_data&0x3)==0) &&
+      (((unsigned int)scratch_buffer&0x7) == 0) && ((input_depth&0xF)==0) && ((filter_height*filter_width&0x3)==0))
+  {
+    {
+      //tbd : batch = 1, need to handle other values and in_x_min/max= 0 .. need toc heck for other values
+      for (int in_y = 0; in_y < input_height; ++in_y)
+      {
+        for (int in_x = 0; in_x < input_width; ++in_x)
+        {
+          const int out_x_orig = in_x*stride_width - pad_width;
+          const int out_y_orig = in_y*stride_height - pad_height;
+          int filt_x_min = -out_x_orig;
+          int filt_x_max = output_width - out_x_orig;
+          int filt_y_min = -out_y_orig;
+          int filt_y_max = output_height - out_y_orig;
+          filt_x_min = (filt_x_min < filter_width) ? filt_x_min : filter_width;
+          filt_x_min = (filt_x_min < 0) ? 0 : filt_x_min;
+          filt_x_max = (filt_x_max < filter_width) ? filt_x_max : filter_width;
+          filt_x_max = (filt_x_max < 0) ? 0 : filt_x_max;
+          filt_y_min = (filt_y_min < filter_height) ? filt_y_min : filter_height;
+          filt_y_min = (filt_y_min < 0) ? 0 : filt_y_min;
+          filt_y_max = (filt_y_max < filter_height) ? filt_y_max : filter_height;
+          filt_y_max = (filt_y_max < 0) ? 0 : filt_y_max;
+          pinp =  (WORD8*)&input_data[in_y*input_width*input_depth+in_x*input_depth];
+          for (int in_channel = 0; in_channel < input_depth; in_channel+=16)
+          {
+            ae_int16x4 d_inp, d_inp1, d_inp2, d_inp3;
+            AE_L8X4F_IP(d_inp, pinp, sizeof(WORD32));
+            AE_L8X4F_IP(d_inp1, pinp, sizeof(WORD32));
+            AE_L8X4F_IP(d_inp2, pinp, sizeof(WORD32));
+            AE_L8X4F_IP(d_inp3, pinp, sizeof(WORD32));
+            d_inp = AE_SRAI16(d_inp, 8);
+            d_inp1 = AE_SRAI16(d_inp1, 8);
+            d_inp2 = AE_SRAI16(d_inp2, 8);
+            d_inp3 = AE_SRAI16(d_inp3, 8);
+            d_inp = AE_ADD16(d_inp, AE_MOVDA16(input_offset));
+            d_inp1 = AE_ADD16(d_inp1,AE_MOVDA16(input_offset));
+            d_inp2 = AE_ADD16(d_inp2,AE_MOVDA16(input_offset));
+            d_inp3 = AE_ADD16(d_inp3,AE_MOVDA16(input_offset));
+            for (int filter_y = filt_y_min; filter_y < filt_y_max; ++filter_y)
+            {
+              for (int filter_x = filt_x_min; filter_x < filt_x_max; ++filter_x)
+              {
+                // Compute output element location.
+                int out_x = out_x_orig + filter_x;//out_x_origin + filter_x;
+                int out_y = out_y_orig + filter_y;//out_y_origin + filter_y;
+                ae_int32 *pscratch_src = (ae_int32*)&scratch_buffer[out_y*output_width*output_depth+out_x*output_depth];
+                ae_int32x2 d_scr;
+                WORD8* pfilt = (WORD8*)&filter_data[filter_y*filter_width*input_depth + filter_x*input_depth + in_channel];
+                ae_int16x4 d_fil, d_fil1, d_fil2, d_fil3;
+
+                AE_L8X4F_IP(d_fil, pfilt, sizeof(WORD32));
+                AE_L8X4F_IP(d_fil1, pfilt, sizeof(WORD32));
+                AE_L8X4F_IP(d_fil2, pfilt, sizeof(WORD32));
+                AE_L8X4F_XP(d_fil3, pfilt, (stride1-12));
+                d_fil = AE_SRAI16(d_fil, 8);
+                d_fil1 = AE_SRAI16(d_fil1, 8);
+                d_fil2 = AE_SRAI16(d_fil2, 8);
+                d_fil3 = AE_SRAI16(d_fil3, 8);
+
+                for (int out_channel = 0; out_channel < output_depth; ++out_channel)
+                {
+                  ae_int64 acc = 0;
+                  d_scr = AE_L32_I(pscratch_src, 0);
+                  AE_MULAAAAQ16(acc, d_inp, d_fil);
+                  AE_MULAAAAQ16(acc, d_inp1, d_fil1);
+                  AE_MULAAAAQ16(acc, d_inp2, d_fil2);
+                  AE_MULAAAAQ16(acc, d_inp3, d_fil3);
+                  d_scr = AE_ADD32(d_scr, AE_MOVINT32_FROMINT64(acc));
+
+                  d_fil  = AE_L8X4F_I( pfilt, 0*sizeof(WORD32));
+                  d_fil1 = AE_L8X4F_I( pfilt, 1*sizeof(WORD32));
+                  d_fil2 = AE_L8X4F_I( pfilt, 2*sizeof(WORD32));
+                  d_fil3 = AE_L8X4F_I( pfilt, 3*sizeof(WORD32));
+                  d_fil  = AE_SRAI16(d_fil, 8);
+                  d_fil1 = AE_SRAI16(d_fil1, 8);
+                  d_fil2 = AE_SRAI16(d_fil2, 8);
+                  d_fil3 = AE_SRAI16(d_fil3, 8);
+
+                  pfilt += stride1;
+                  AE_S32_L_IP(d_scr, pscratch_src, sizeof(WORD32));
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+  else if(input_data && filter_data && scratch_buffer &&
+      (((unsigned int)input_data&0x3)==0) && (((unsigned int)filter_data&0x3)==0) &&
+      (((unsigned int)scratch_buffer&0x7) == 0) && ((input_depth&0x3)==0) && ((filter_height*filter_width&0x3)==0))
+  {
+    {
+      //tbd : batch = 1, need to handle other values and in_x_min/max= 0 .. need toc heck for other values
+      for (int in_y = 0; in_y < input_height; ++in_y)
+      {
+        for (int in_x = 0; in_x < input_width; ++in_x)
+        {
+          const int out_x_orig = in_x*stride_width - pad_width;
+          const int out_y_orig = in_y*stride_height - pad_height;
+          int filt_x_min = -out_x_orig;
+          int filt_x_max = output_width - out_x_orig;
+          int filt_y_min = -out_y_orig;
+          int filt_y_max = output_height - out_y_orig;
+          filt_x_min = (filt_x_min < filter_width) ? filt_x_min : filter_width;
+          filt_x_min = (filt_x_min < 0) ? 0 : filt_x_min;
+          filt_x_max = (filt_x_max < filter_width) ? filt_x_max : filter_width;
+          filt_x_max = (filt_x_max < 0) ? 0 : filt_x_max;
+          filt_y_min = (filt_y_min < filter_height) ? filt_y_min : filter_height;
+          filt_y_min = (filt_y_min < 0) ? 0 : filt_y_min;
+          filt_y_max = (filt_y_max < filter_height) ? filt_y_max : filter_height;
+          filt_y_max = (filt_y_max < 0) ? 0 : filt_y_max;
+          pinp =  (WORD8*)&input_data[in_y*input_width*input_depth+in_x*input_depth];
+          for (int in_channel = 0; in_channel < input_depth; in_channel+=4)
+          {
+            ae_int16x4 d_inp;
+            AE_L8X4F_IP(d_inp, pinp, sizeof(WORD32));
+            d_inp = AE_SRAI16(d_inp, 8);
+            d_inp = AE_ADD16(d_inp, AE_MOVDA16(input_offset));
+            for (int filter_y = filt_y_min; filter_y < filt_y_max; ++filter_y)
+            {
+              for (int filter_x = filt_x_min; filter_x < filt_x_max; ++filter_x)
+              {
+                // Compute output element location.
+                int out_x = out_x_orig + filter_x;//out_x_origin + filter_x;
+                int out_y = out_y_orig + filter_y;//out_y_origin + filter_y;
+                ae_int32 *pscratch_src = (ae_int32*)&scratch_buffer[out_y*output_width*output_depth+out_x*output_depth];
+                ae_int32x2 d_scr;
+                WORD8* pfilt = (WORD8*)&filter_data[filter_y*filter_width*input_depth + filter_x*input_depth + in_channel];
+                ae_int16x4 d_fil;
+
+                AE_L8X4F_XP(d_fil, pfilt, stride1);
+                d_fil = AE_SRAI16(d_fil, 8);
+
+                for (int out_channel = 0; out_channel < output_depth; ++out_channel)
+                {
+                  ae_int64 acc = 0;
+                  d_scr = AE_L32_I(pscratch_src, 0);
+                  AE_MULAAAAQ16(acc, d_inp, d_fil);
+                  d_scr = AE_ADD32(d_scr, AE_MOVINT32_FROMINT64(acc));
+                  AE_L8X4F_XP(d_fil, pfilt, stride1);
+                  d_fil = AE_SRAI16(d_fil, 8);
+                  AE_S32_L_IP(d_scr, pscratch_src, sizeof(WORD32));
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+  else
+  {
+    {
+      for (int in_y = 0; in_y < input_height; ++in_y)
+      {
+        for (int in_x = 0; in_x < input_width; ++in_x)
+        {
+          for (int in_channel = 0; in_channel < input_depth; ++in_channel)
+          {
+            const int out_x_origin = (in_x * stride_width) - pad_width;
+            const int out_y_origin = (in_y * stride_height) - pad_height;
+            for (int filter_y = 0; filter_y < filter_height; ++filter_y)
+            {
+              for (int filter_x = 0; filter_x < filter_width; ++filter_x)
+              {
+                const int out_x = out_x_origin + filter_x;
+                const int out_y = out_y_origin + filter_y;
+                if ((out_x >= 0) && (out_x < output_width) && (out_y >= 0) && (out_y < output_height))
+                {
+                  for (int out_channel = 0; out_channel < output_depth; ++out_channel)
+                  {
+                    const int32_t input_value = input_data[((in_y)*input_width+in_x)*input_depth+in_channel] + input_offset;
+                    const int32_t filter_value = filter_data[(((out_channel*filter_height)+filter_y)*filter_width+filter_x)*input_depth+in_channel];
+                    scratch_buffer[((out_y)*output_width+out_x)*output_depth+out_channel] += input_value * filter_value;
+                  }
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+
+  if(bias_data)
+  {
+    ae_int32x2 acc0, acc1, dbias;
+    ae_int32 *pbias = (ae_int32*)bias_data;
+
+    for (int out_channel = 0; out_channel < output_depth; ++out_channel)
+    {
+#if TFLITE_SINGLE_ROUNDING
+      int left_shift = output_shift[out_channel];
+      int right_shift = output_shift[out_channel];
+      (void)right_shift;
+#else /* #if TFLITE_SINGLE_ROUNDING */
+      int left_shift = output_shift[out_channel] < 0 ? 0 : output_shift[out_channel];
+      int right_shift = output_shift[out_channel] > 0 ? 0 : -output_shift[out_channel];
+#endif /* #if TFLITE_SINGLE_ROUNDING */
+
+      pscratch = (ae_int32*)&scratch_buffer[out_channel];
+      WORD8 *pout = (WORD8*)&output_data[out_channel];
+      ae_int32 *pscratch1 = (ae_int32*)&scratch_buffer[((output_height*output_width)>>1)*output_depth+out_channel];
+      WORD8 *pout1 = (WORD8*)&output_data[((output_height*output_width)>>1)*output_depth+out_channel];
+      AE_L32_IP(dbias, pbias, sizeof(WORD32));
+      AE_L32_XP(acc0, pscratch, output_depth*sizeof(WORD32));
+      AE_L32_XP(acc1, pscratch1, output_depth*sizeof(WORD32));
+      ae_int32 out_mult = output_multiplier[out_channel];
+      for (int i = 0; i < ((output_height*output_width)>>1); i++)
+      {
+        ae_int32x2 out32;
+        ae_int32x2 acc;
+        acc0 = AE_ADD32(acc0, dbias);
+        acc1 = AE_ADD32(acc1, dbias);
+        acc = AE_SEL32_HH(acc0,acc1);
+        MPY_BY_QUANT_MULT_X2_OUT32(out32, acc, out_mult, left_shift, right_shift);
+        out32 = AE_ADD32(out32, AE_MOVDA32(output_offset));
+        out32 = AE_MIN32(AE_MOVDA32(127), AE_MAX32(out32, AE_MOVDA32(-128)));
+        AE_L32_XP(acc0, pscratch, output_depth*sizeof(WORD32));
+        AE_L32_XP(acc1, pscratch1, output_depth*sizeof(WORD32));
+        *pout = (WORD8)AE_MOVAD32_H(out32);
+        pout+=output_depth;
+        *pout1 = (WORD8)AE_MOVAD32_L(out32);
+        pout1+=output_depth;
+      }
+      if((output_height*output_width) & 1)
+      {
+        ae_int16x4 out16;
+        ae_int32x2 out1_32;
+        acc1 = AE_ADD32(acc1, dbias);
+        MPY_BY_QUANT_MULT_X2_OUT32(out1_32, acc1, out_mult, left_shift, right_shift);
+        out1_32 = AE_ADD32(out1_32, AE_MOVDA32(output_offset));
+        out1_32 = AE_MIN32(AE_MOVDA32(127), AE_MAX32(out1_32, AE_MOVDA32(-128)));
+        out16 = AE_SAT16X4(out1_32, out1_32);
+        *pout1 = (WORD8)AE_MOVAD16_0(out16);
+      }
+    }
+  }
+  else
+  {
+    pscratch = (ae_int32*)scratch_buffer;
+    WORD8 *pout = (WORD8*)output_data;
+    for (int i = 0; i < output_height*output_width; i++)
+    {
+      for (int out_channel = 0; out_channel < output_depth; ++out_channel)
+      {
+#if TFLITE_SINGLE_ROUNDING
+        int left_shift = output_shift[out_channel];
+        int right_shift = output_shift[out_channel];
+        (void)right_shift;
+#else /* #if TFLITE_SINGLE_ROUNDING */
+        int left_shift = output_shift[out_channel] < 0 ? 0 : output_shift[out_channel];
+        int right_shift = output_shift[out_channel] > 0 ? 0 : -output_shift[out_channel];
+#endif /* #if TFLITE_SINGLE_ROUNDING */
+        ae_int32x2 acc, out0_32;
+        ae_int16x4 out16;
+        AE_L32_IP(acc, pscratch, sizeof(WORD32));
+        MPY_BY_QUANT_MULT_X2_OUT32(out0_32, acc, output_multiplier[out_channel], left_shift, right_shift);
+        out0_32 = AE_ADD32(out0_32, AE_MOVDA32(output_offset));
+        out0_32 = AE_MIN32(AE_MOVDA32(127), AE_MAX32(out0_32, AE_MOVDA32(-128)));
+        out16 = AE_SAT16X4(out0_32, out0_32);
+        *pout++ = (WORD8)AE_MOVAD16_0(out16);
+      }
+    }
+  }
+}
+
+static inline void tconv2d_std_reorder_kernel_sym8s
+    (pVOID p_scratch
+     ,const WORD8* p_kernel
+     ,WORD32 kernel_height
+     ,WORD32 kernel_width
+     ,WORD32 input_channels
+     ,WORD32 output_channels
+     ,WORD32 x_stride
+     ,WORD32 y_stride
+     ,WORD32 subker_size
+    )
+{
+  WORD32 kIdx, kIdy;
+  WORD32 kernelIdx;
+
+  WORD32 kx, ky, outCh, inIdx;
+  WORD32 kxStart, kyStart;
+
+  WORD32 input_channels_pad = PADDED_SIZE(input_channels, ALIGNMENT >> 1);
+  WORD32 pitch_d = input_channels;
+  WORD32 pitch_w = kernel_width * input_channels;
+  WORD32 pitch_h = kernel_height * kernel_width * input_channels;
+
+  WORD32 subkermax_w = (kernel_width + x_stride - 1) / x_stride;
+  WORD32 subkermax_h = (kernel_height + y_stride - 1) / y_stride;
+
+  WORD8 *p_ker;
+
+  /* Conversion from NDWH -> DNWH,                       */
+  /* transposing of kernels and formation of sub-kernels */
+  for (kIdy = 0; kIdy < y_stride; kIdy++)
+  {
+    for (kIdx = 0; kIdx < x_stride; kIdx++)
+    {
+      kernelIdx = kIdy * x_stride + kIdx;
+      WORD8 *p_dst = ((WORD8 *)p_scratch + kernelIdx * subker_size);
+
+      kyStart = kernel_height - 1 - ((kernel_height + y_stride - kIdy - 1) % y_stride);
+      kxStart = kernel_width - 1 - ((kernel_width + x_stride - kIdx - 1) % x_stride);
+      WORD32 subker_w = (kernel_width + x_stride - kIdx - 1) / x_stride;
+      WORD32 subker_h = (kernel_height + y_stride - kIdy - 1) / y_stride;
+
+      for (outCh = 0; outCh < output_channels; outCh++)      /* N */
+      {
+        p_dst += (subkermax_h - subker_h) * subkermax_w * input_channels_pad; /* Add top padding to the subkernel */
+        for (ky = kyStart; ky >= 0; ky -= y_stride)          /* H */
+        {
+          p_dst += (subkermax_w - subker_w) * input_channels_pad; /* Add left padding to the subkernel */
+          for (kx = kxStart; kx >= 0; kx -= x_stride)        /* W */
+          {
+            p_ker = (WORD8 *)&p_kernel[inIdx = outCh * pitch_h + ky * pitch_w + kx * pitch_d];
+            memcpy(p_dst, p_ker, input_channels);
+            p_dst+=input_channels_pad;
+          }
+        }
+      }
+    }
+  }
+}
+
+static inline void tconv_pad(
+    WORD32 out_width,
+    WORD32 out_height,
+    WORD32 out_channels,
+    WORD32 out_channels_offset,
+    WORD32 out_width_offset,
+    WORD32 out_height_offset,
+    const WORD32* __restrict__ p_bias,
+    WORD8 *p_out,
+    WORD32 * p_out_multiplier,
+    WORD32 * p_out_shift,
+    WORD32 out_offset,
+    WORD32 idx_width,
+    WORD32 idx_height)
+{
+  WORD32 i, j, k;
+  /* When kernel has no valid input for convolution, output is just bias */
+  for(i = idx_height; i < out_height; i++)
+  {
+    for(j = idx_width; j < out_width; j++)
+    {
+      WORD8 *ptrout = (WORD8*)&p_out[i * out_height_offset + j * out_width_offset];
+      ae_int32 *pbias = (ae_int32*)p_bias;
+      ae_int32x2 q1;
+      for(k = 0; k < out_channels; k++)
+      {
+        AE_L32_IP(q1, pbias, 4);
+        ae_int32x2 acc;
+        int left_shift, right_shift;
+#if TFLITE_SINGLE_ROUNDING
+        left_shift = right_shift = p_out_shift[k];
+        (void)right_shift;
+#else /* #if TFLITE_SINGLE_ROUNDING */
+        left_shift = p_out_shift[k] < 0 ? 0 : p_out_shift[k];
+        right_shift = p_out_shift[k] > 0 ? 0 : -p_out_shift[k];
+#endif
+        MPY_BY_QUANT_MULT_X2_OUT32(acc, q1, p_out_multiplier[k], left_shift, right_shift);
+        acc = AE_ADD32S(acc, AE_MOVDA32(out_offset));
+        acc = AE_MIN32(AE_MOVDA32(127), AE_MAX32(acc, AE_MOVDA32(-128)));
+        *ptrout = (WORD8)AE_MOVAD32_H(acc);
+        ptrout+=out_channels_offset;
+      }
+    }
+  }
+}
+
+static inline void transpose_conv2d_std_sym8sxasym8s(WORD8* output_data,
+    const WORD8* input_data,
+    const WORD8* filter_data,
+    const WORD32* bias_data,
+    int stride_width, int stride_height,
+    int pad_width, int pad_height,
+    int input_depth, int output_depth,
+    int input_height, int input_width,
+    int filter_height, int filter_width,
+    int output_height, int output_width,
+    int num_elements,
+    int input_offset, int output_offset,
+    int *output_shift, int *output_multiplier,
+    pVOID scratch_buffer)
+{
+  /* Transpose and Reorder the kernel into sub-kernels */
+  WORD32 subkerX_max = (filter_width + stride_width - 1) / stride_width;
+  WORD32 subkerY_max = (filter_height + stride_height - 1) / stride_height;
+  WORD32 n_subker = stride_width * stride_height;
+  WORD32 input_depth_pad = PADDED_SIZE(input_depth, (ALIGNMENT>>1));
+  WORD32 subker_size = subkerX_max * subkerY_max * input_depth_pad * output_depth;
+  /* memset the kernel reordering memory on scratch */
+  memset(scratch_buffer, (WORD8)0, subker_size * n_subker);
+
+  tconv2d_std_reorder_kernel_sym8s(scratch_buffer, filter_data, filter_height, filter_width, input_depth, output_depth, stride_width, stride_height, subker_size);
+
+  /* Calculate padding values */
+  WORD32 x_pad = subkerX_max - 1;
+  WORD32 y_pad = subkerY_max - 1;
+  WORD32 y_b_pad = subkerY_max - 1;
+
+  /* Calculate valid output dims */
+  WORD32 orig_valid_out_h = XT_MIN(output_height, filter_height + stride_height * (input_height -1) - pad_height);
+  WORD32 orig_valid_out_w = XT_MIN(output_width, filter_width + stride_width * (input_width -1) - pad_width);
+  WORD32 valid_out_h = orig_valid_out_h + pad_height;
+  WORD32 valid_out_w = orig_valid_out_w + pad_width;
+  WORD32 out_h_per_subker = orig_valid_out_h / stride_height;
+  WORD32 pad_h_per_subker = pad_height / stride_height;
+
+  /* Calculate valid and actual output offsets */
+  WORD32 out_data_format = 0; // NHWC
+  WORD32 out_channels_offset = out_data_format ? valid_out_h * valid_out_w : 1;
+  WORD32 final_out_channels_offset = out_data_format ? output_height * output_width : 1;
+  WORD32 final_out_height_offset = out_data_format ? output_width : output_width * output_depth;
+  WORD32 final_out_width_offset = out_data_format ? 1 : output_depth;
+
+  /* Calculate pointers for different sections on scratch buffer */
+  WORD32 kernel_size = PADDED_SIZE(subker_size * n_subker, 4);
+  WORD8 *p_trp_ker = (WORD8 *)scratch_buffer;
+  WORD8 *p_scr_cnv = (WORD8 *)((WORD8 *)scratch_buffer + kernel_size);
+
+  /* Handle cases that have less valid output dimension than the output dimension given by the user */
+  if(((orig_valid_out_h) < output_height))
+  {
+    tconv_pad(output_width, output_height, output_depth, final_out_channels_offset, final_out_width_offset, final_out_height_offset, bias_data, output_data, output_multiplier, output_shift, output_offset, 0, XT_MAX(0,orig_valid_out_h));
+  }
+  if((orig_valid_out_w) < output_width)
+  {
+    tconv_pad(output_width, output_height, output_depth, final_out_channels_offset, final_out_width_offset, final_out_height_offset, bias_data, output_data, output_multiplier, output_shift, output_offset, XT_MAX(0,orig_valid_out_w), 0);
+  }
+  if((out_h_per_subker < 0))
+  {
+    tconv_pad(output_width, output_height, output_depth, final_out_channels_offset, final_out_width_offset, final_out_height_offset, bias_data, output_data, output_multiplier, output_shift, output_offset, 0, 0);
+    return;
+  }
+
+  WORD32 j;
+  WORD32 input_bytewidth = 1;
+  VOID *pp_inp = (VOID *)(input_data);
+
+  /* Conv 2D Standard code init */
+  /* Here the x-pad and y-pad values are controlled by the filter dimensions
+   * x-r-pad = filter_width - 1 and y-b-pad = filter_height - 1
+   * x_pad and y_pad depend on kernel dimension and the padding.
+  */
+  xa_nn_conv_state_t *p_state = (xa_nn_conv_state_t *)p_scr_cnv;
+  xa_nn_transpose_conv_init_state((void*)p_state
+      ,(void*)p_trp_ker
+      ,input_height
+      ,input_depth
+      ,subkerY_max
+      ,subkerX_max
+      ,PREC_ASYM8S);
+
+  /* When kernel convolves over input region */
+  // Initialize circular buffer
+  conv2d_std_init_cir_buf_asym8(input_depth, input_depth_pad, input_bytewidth, input_width, input_height, y_pad, y_b_pad, x_pad, subkerX_max, 1, (VOID**)&pp_inp, p_state, -input_offset);
+
+  // Index to padded input width
+  WORD32 idx_beg_inp_width_pad = subkerX_max - 1;
+  idx_beg_inp_width_pad = idx_beg_inp_width_pad < 0 ? 0 : idx_beg_inp_width_pad;
+
+  WORD8 *po_tmp;
+  WORD32 rem_val_out_w = valid_out_w % stride_width;
+  WORD32 pad_w = pad_width;
+
+  // Process Loop to compute one output plane [out_height x out_channels] per iteration
+  WORD32 out_w_looopcnt = valid_out_w / stride_width;
+
+  for(j = 0; j < out_w_looopcnt; j++)
+  {
+    // Add x_stride x (input_height x input_channels) new planes to circular buffer
+    conv2d_std_update_cir_buf_asym8(input_depth, input_depth_pad, input_bytewidth, input_width, input_height, y_pad, y_b_pad, x_pad, subkerX_max, 1, (VOID**)&pp_inp, idx_beg_inp_width_pad, p_state, -input_offset);
+
+    // Update index to input width padded
+    idx_beg_inp_width_pad += 1;
+
+    int kernelIdx;
+    for (int kIdx = 0; kIdx < stride_width; kIdx++, pad_w--)
+    {
+      WORD32 rem_val_out_h = (valid_out_h - pad_height) % stride_height;
+      WORD32 is_pad_w = (pad_w > 0);
+
+      if(!is_pad_w)
+      {
+        WORD32 pad_h_ky = stride_height - (pad_height % stride_height); // Required to handle valid inp_h for subkernel
+        po_tmp = output_data;
+        for (int kIdy = 0; kIdy < stride_height; kIdy++, rem_val_out_h--, pad_h_ky--)
+        {
+          kernelIdx = ((kIdy + pad_height) % stride_height) * stride_width + kIdx;
+          WORD8 *p_subkernel = ((WORD8 *)p_trp_ker + kernelIdx * subker_size);
+          WORD32 rem_out_h_per_subker = (rem_val_out_h > 0) ? 1 : 0;
+
+          // Adjust the circ_buf pointer as per pad_height
+          WORD32 cir_buf_inp_offset = pad_h_per_subker * input_depth_pad * subkerX_max;
+          cir_buf_inp_offset = (pad_h_ky > 0) ? cir_buf_inp_offset : cir_buf_inp_offset + input_depth_pad * subkerX_max;
+          WORD8 *p_inp_cir_buf = p_state->cir_buf.p_curr;
+          AE_ADDCIRC16X4_XC((ae_int16x4 *)p_inp_cir_buf, cir_buf_inp_offset * input_bytewidth);
+          // Convolution using matXvec with matrix as circular buffer
+          xa_nn_matXvec_sym8sxasym8s_asym8s_circ
+          (po_tmp /* output */
+           ,p_inp_cir_buf/* matrix: rows x cols */
+           ,p_subkernel /* vec: cols */
+           ,bias_data /* bias */
+           ,out_h_per_subker + rem_out_h_per_subker /* rows */
+           ,input_depth_pad * subkerX_max * subkerY_max /* cols */
+           ,input_depth_pad * subkerX_max /* row_offset */
+           ,output_depth /* vec_count */
+           ,input_depth_pad * subkerX_max * subkerY_max /* vec_stride */
+           ,out_channels_offset /* out_col_offset */
+           ,final_out_height_offset * stride_height /* out_row_offset */
+           ,input_offset
+           ,output_multiplier
+           ,output_shift
+           ,output_offset
+          );
+          po_tmp += final_out_height_offset;
+        }
+      }
+      output_data = is_pad_w ? output_data : output_data + output_depth;
+    }
+  }
+
+  /* Tail loop depending on remaining valid_out_width */
+  if(rem_val_out_w)
+  {
+    // Add x_stride x (input_height x input_channels) new planes to circular buffer
+    conv2d_std_update_cir_buf_asym8(input_depth, input_depth_pad, input_bytewidth, input_width, input_height, y_pad, y_b_pad, x_pad, subkerX_max, 1, (VOID**)&pp_inp, idx_beg_inp_width_pad, p_state, -input_offset);
+
+    // Update index to input width padded
+    idx_beg_inp_width_pad += 1;
+
+    int kernelIdx;
+    for (int kIdx = 0; kIdx < rem_val_out_w; kIdx++, pad_w--)
+    {
+      WORD32 rem_val_out_h = (valid_out_h - pad_height) % stride_height;
+      WORD32 is_pad_w = (pad_w > 0);
+
+      if(!is_pad_w)
+      {
+        WORD32 pad_h_ky = stride_height - (pad_height % stride_height); // Required to handle valid inp_h for subkernel
+        po_tmp = output_data;
+        for (int kIdy = 0; kIdy < stride_height; kIdy++, rem_val_out_h--, pad_h_ky--)
+        {
+          kernelIdx = ((kIdy + pad_height) % stride_height) * stride_width + kIdx;
+          WORD8 *p_subkernel = ((WORD8 *)p_trp_ker + kernelIdx * subker_size);
+          WORD32 rem_out_h_per_subker = (rem_val_out_h > 0) ? 1 : 0;
+          // Adjust the circ_buf pointer as per pad_height
+          WORD32 cir_buf_inp_offset = pad_h_per_subker * input_depth_pad * subkerX_max;
+          cir_buf_inp_offset = (pad_h_ky > 0) ? cir_buf_inp_offset : cir_buf_inp_offset + input_depth_pad * subkerX_max;
+          WORD8 *p_inp_cir_buf = p_state->cir_buf.p_curr;
+          AE_ADDCIRC16X4_XC((ae_int16x4 *)p_inp_cir_buf, cir_buf_inp_offset * input_bytewidth);
+
+          // Convolution using matXvec with matrix as circular buffer
+          xa_nn_matXvec_sym8sxasym8s_asym8s_circ
+          (po_tmp /* output */
+           ,p_inp_cir_buf/* matrix: rows x cols */
+           ,p_subkernel /* vec: cols */
+           ,bias_data /* bias */
+           ,out_h_per_subker + rem_out_h_per_subker /* rows */
+           ,input_depth_pad * subkerX_max * subkerY_max /* cols */
+           ,input_depth_pad * subkerX_max /* row_offset */
+           ,output_depth /* vec_count */
+           ,input_depth_pad * subkerX_max * subkerY_max /* vec_stride */
+           ,out_channels_offset /* out_col_offset */
+           ,final_out_height_offset * stride_height /* out_row_offset */
+           ,input_offset
+           ,output_multiplier
+           ,output_shift
+           ,output_offset
+          );
+          po_tmp += final_out_height_offset;
+        }
+      }
+      output_data = is_pad_w ? output_data : output_data + output_depth;
+    }
+  }
+}
+
+int xa_nn_transpose_conv_sym8sxasym8s(WORD8* output_data,
+    const WORD8* input_data,
+    const WORD8* filter_data,
+    const WORD32* bias_data,
+    int stride_width, int stride_height,
+    int pad_width, int pad_height,
+    int input_depth, int output_depth,
+    int input_height, int input_width,
+    int filter_height, int filter_width,
+    int output_height, int output_width,
+    int num_elements,
+    int input_offset, int output_offset,
+    int *output_shift, int *output_multiplier,
+    int32_t* scratch_buffer)
+{
+  /* NULL pointer checks */
+  XA_NNLIB_ARG_CHK_PTR(output_data, -1);
+  XA_NNLIB_ARG_CHK_PTR(filter_data, -1);
+  XA_NNLIB_ARG_CHK_PTR(input_data, -1);
+  XA_NNLIB_ARG_CHK_PTR(scratch_buffer, -1);
+  /* Pointer alignment checks */
+  XA_NNLIB_ARG_CHK_ALIGN(output_data, sizeof(WORD8), -1);
+  XA_NNLIB_ARG_CHK_ALIGN(filter_data, sizeof(WORD8), -1);
+  XA_NNLIB_ARG_CHK_ALIGN(input_data, sizeof(WORD8), -1);
+  XA_NNLIB_ARG_CHK_ALIGN(bias_data, sizeof(WORD32), -1);
+  XA_NNLIB_ARG_CHK_ALIGN(scratch_buffer, sizeof(WORD64), -1);
+  /* Basic Parameter checks */
+  XA_NNLIB_ARG_CHK_COND((input_height <= 0 || input_width <= 0), -1);
+  XA_NNLIB_ARG_CHK_COND((input_depth <= 0), -1);
+  XA_NNLIB_ARG_CHK_COND((filter_height <= 0 || filter_width <= 0), -1);
+  XA_NNLIB_ARG_CHK_COND((output_depth <= 0), -1);
+  XA_NNLIB_ARG_CHK_COND((stride_height <= 0 || stride_width <= 0), -1);
+  XA_NNLIB_ARG_CHK_COND((pad_height < 0 || pad_width < 0), -1);
+  XA_NNLIB_ARG_CHK_COND((output_height <= 0 || output_width <= 0), -1);
+  XA_NNLIB_ARG_CHK_COND((num_elements <= 0), -1);
+  XA_NNLIB_ARG_CHK_COND((input_offset < -127 || input_offset > 128), -1);
+  XA_NNLIB_ARG_CHK_COND((output_offset < -128 || output_offset > 127), -1);
+
+  int ker_grt_inp = (filter_width > input_width || filter_height > input_height);
+  int str_leq_ker = (stride_width <= filter_width && stride_height <= filter_height);
+
+  if(!ker_grt_inp && str_leq_ker)
+  {
+    transpose_conv2d_std_sym8sxasym8s(output_data, input_data, filter_data, bias_data,
+      stride_width, stride_height, pad_width, pad_height, input_depth, output_depth,
+      input_height, input_width, filter_height, filter_width, output_height, output_width,
+      num_elements, input_offset, output_offset, output_shift, output_multiplier, scratch_buffer);
+  }
+  else
+  {
+    tconv2d_sym8sxasym8s(output_data, input_data, filter_data, bias_data,
+      stride_width, stride_height, pad_width, pad_height, input_depth, output_depth,
+      input_height, input_width, filter_height, filter_width, output_height, output_width,
+      num_elements, input_offset, output_offset, output_shift, output_multiplier, scratch_buffer);
+  }
+  return 0;
+}
diff --git a/algo/kernels/cnn/hifi4/xa_nn_transpose_conv_sym8sxsym16s.c b/algo/kernels/cnn/hifi4/xa_nn_transpose_conv_sym8sxsym16s.c
index 095e18a..d9c3294 100644
--- a/algo/kernels/cnn/hifi4/xa_nn_transpose_conv_sym8sxsym16s.c
+++ b/algo/kernels/cnn/hifi4/xa_nn_transpose_conv_sym8sxsym16s.c
@@ -613,7 +613,7 @@ static inline void transpose_conv2d_std_sym8sxsym16s(WORD16* output_data,
     idx_beg_inp_width_pad += 1;
 
     int kernelIdx;
-    for (int kIdx = 0; kIdx < rem_val_out_w; kIdx++)
+    for (int kIdx = 0; kIdx < rem_val_out_w; kIdx++, pad_w--)
     {
       WORD32 rem_val_out_h = (valid_out_h - pad_height) % stride_height;
       WORD32 is_pad_w = (pad_w > 0);
diff --git a/algo/kernels/matXvec/hifi4/xa_nn_matXvec_asym8sxasym8s.c b/algo/kernels/matXvec/hifi4/xa_nn_matXvec_asym8sxasym8s.c
index 7bbbc8d..e3c65c1 100644
--- a/algo/kernels/matXvec/hifi4/xa_nn_matXvec_asym8sxasym8s.c
+++ b/algo/kernels/matXvec/hifi4/xa_nn_matXvec_asym8sxasym8s.c
@@ -27,7 +27,6 @@ typedef void (*_dot_prod_1_rows_1_vecs_kernel)(
       const WORD8* p_mat,
       const WORD8* p_vec,
       WORD32 cols1,
-      WORD32 mat_zero_bias,
       WORD32 vec_zero_bias);
 
 typedef void (*_dot_prod_4_rows_1_vecs_kernel)(
@@ -37,7 +36,6 @@ typedef void (*_dot_prod_4_rows_1_vecs_kernel)(
     const WORD8* p_vec_0,
     WORD32       cols1,
     WORD32       row_stride1,
-    WORD32       mat_zero_bias,
     WORD32       vec_zero_bias);
 
 
@@ -48,7 +46,6 @@ static inline void _xa_nn_dot_product_4_rows_1_vec_mat_unaligned_vec_aligned
     ,const WORD8* p_vec_0
     ,WORD32       cols1
     ,WORD32       row_stride1
-    ,WORD32       mat_zero_bias
     ,WORD32       vec_zero_bias)
 {
   int c_itr = 0;
@@ -68,12 +65,22 @@ static inline void _xa_nn_dot_product_4_rows_1_vec_mat_unaligned_vec_aligned
 
   ae_int32x2 acc_row0_vec0 = *out_0_0;
   ae_int32x2 acc_row1_vec0 = *out_1_0;
+
+  out_0 = AE_CVT64F32_H(acc_row0_vec0);
   out_1 = AE_CVT64F32_L(acc_row0_vec0);
+  out_2 = AE_CVT64F32_H(acc_row1_vec0);
   out_3 = AE_CVT64F32_L(acc_row1_vec0);
-  out_0 = AE_SRAI64(AE_MOVINT64_FROMINT32X2(acc_row0_vec0), 32);
+#if XCHAL_HAVE_HIFI1
+  out_0 = AE_SRAI64(out_0, 32);
   out_1 = AE_SRAI64(out_1, 32);
-  out_2 = AE_SRAI64(AE_MOVINT64_FROMINT32X2(acc_row1_vec0), 32);
+  out_2 = AE_SRAI64(out_2, 32);
   out_3 = AE_SRAI64(out_3, 32);
+#else
+  out_0 = AE_SRAI64(out_0, 32-8);
+  out_1 = AE_SRAI64(out_1, 32-8);
+  out_2 = AE_SRAI64(out_2, 32-8);
+  out_3 = AE_SRAI64(out_3, 32-8);
+#endif
 
   PRIME_8X4F(p_mat_0_tmp, d_mat0_la);
   PRIME_8X4F(p_mat_1_tmp, d_mat1_la);
@@ -95,16 +102,9 @@ static inline void _xa_nn_dot_product_4_rows_1_vec_mat_unaligned_vec_aligned
     AE_LA8X4F_IP(d_mat2, d_mat2_la, p_mat_2_tmp);
     AE_LA8X4F_IP(d_mat3, d_mat3_la, p_mat_3_tmp);
     AE_L8X4F_IP(d_vec, p_vec, 4);
-    d_mat0 = AE_SRAI16(d_mat0, 8);
-    d_mat1 = AE_SRAI16(d_mat1, 8);
-    d_mat2 = AE_SRAI16(d_mat2, 8);
-    d_mat3 = AE_SRAI16(d_mat3, 8);
     d_vec = AE_SRAI16(d_vec, 8);
 #endif
-    d_mat0 = AE_ADD16(d_mat0, AE_MOVDA16(mat_zero_bias));
-    d_mat1 = AE_ADD16(d_mat1, AE_MOVDA16(mat_zero_bias));
-    d_mat2 = AE_ADD16(d_mat2, AE_MOVDA16(mat_zero_bias));
-    d_mat3 = AE_ADD16(d_mat3, AE_MOVDA16(mat_zero_bias));
+
     d_vec = AE_ADD16(d_vec, AE_MOVDA16(vec_zero_bias));
 
     AE_MULAAAAQ16(out_0, d_mat0, d_vec);
@@ -132,16 +132,8 @@ static inline void _xa_nn_dot_product_4_rows_1_vec_mat_unaligned_vec_aligned
     AE_LA8X4F_IP(d_mat2, d_mat2_la, p_mat_2_tmp);
     AE_LA8X4F_IP(d_mat3, d_mat3_la, p_mat_3_tmp);
     AE_L8X4F_IP(d_vec, p_vec, 4);
-    d_mat0 = AE_SRAI16(d_mat0, 8);
-    d_mat1 = AE_SRAI16(d_mat1, 8);
-    d_mat2 = AE_SRAI16(d_mat2, 8);
-    d_mat3 = AE_SRAI16(d_mat3, 8);
     d_vec = AE_SRAI16(d_vec, 8);
 #endif
-    d_mat0 = AE_ADD16(d_mat0, AE_MOVDA16(mat_zero_bias));
-    d_mat1 = AE_ADD16(d_mat1, AE_MOVDA16(mat_zero_bias));
-    d_mat2 = AE_ADD16(d_mat2, AE_MOVDA16(mat_zero_bias));
-    d_mat3 = AE_ADD16(d_mat3, AE_MOVDA16(mat_zero_bias));
     d_vec = AE_ADD16(d_vec, AE_MOVDA16(vec_zero_bias));
 
     // nullify the trailing elements in d_vec to ignore trailing columns
@@ -153,6 +145,13 @@ static inline void _xa_nn_dot_product_4_rows_1_vec_mat_unaligned_vec_aligned
     AE_MULAAAAQ16(out_3, d_mat3, d_vec);
   }
 
+#if !XCHAL_HAVE_HIFI1
+  out_0 = AE_SRAI64(out_0, 8);
+  out_1 = AE_SRAI64(out_1, 8);
+  out_2 = AE_SRAI64(out_2, 8);
+  out_3 = AE_SRAI64(out_3, 8);
+#endif
+
   acc_row0_vec0 = AE_SEL32_LL(AE_MOVINT32X2_FROMINT64(out_0), AE_MOVINT32X2_FROMINT64(out_1));
   acc_row1_vec0 = AE_SEL32_LL(AE_MOVINT32X2_FROMINT64(out_2), AE_MOVINT32X2_FROMINT64(out_3));
 
@@ -167,7 +166,6 @@ static inline void _xa_nn_dot_product_4_rows_1_vec_mat_aligned_vec_unaligned
     ,const WORD8* p_vec_0
     ,WORD32       cols1
     ,WORD32       row_stride1
-    ,WORD32       mat_zero_bias
     ,WORD32       vec_zero_bias)
 {
   int c_itr = 0;
@@ -184,12 +182,22 @@ static inline void _xa_nn_dot_product_4_rows_1_vec_mat_aligned_vec_unaligned
   ae_int32x2 acc_row0_vec0 = *out_0_0;
   ae_int32x2 acc_row1_vec0 = *out_1_0;
 
+  out_0 = AE_CVT64F32_H(acc_row0_vec0);
   out_1 = AE_CVT64F32_L(acc_row0_vec0);
+  out_2 = AE_CVT64F32_H(acc_row1_vec0);
   out_3 = AE_CVT64F32_L(acc_row1_vec0);
-  out_0 = AE_SRAI64(AE_MOVINT64_FROMINT32X2(acc_row0_vec0), 32);
+
+#if XCHAL_HAVE_HIFI1
+  out_0 = AE_SRAI64(out_0, 32);
   out_1 = AE_SRAI64(out_1, 32);
-  out_2 = AE_SRAI64(AE_MOVINT64_FROMINT32X2(acc_row1_vec0), 32);
+  out_2 = AE_SRAI64(out_2, 32);
   out_3 = AE_SRAI64(out_3, 32);
+#else
+  out_0 = AE_SRAI64(out_0, 32-8);
+  out_1 = AE_SRAI64(out_1, 32-8);
+  out_2 = AE_SRAI64(out_2, 32-8);
+  out_3 = AE_SRAI64(out_3, 32-8);
+#endif
 
   PRIME_8X4F(p_vec_tmp, d_vec_la);
 
@@ -208,16 +216,8 @@ static inline void _xa_nn_dot_product_4_rows_1_vec_mat_aligned_vec_unaligned
     AE_L8X4F_IP(d_mat2, p_mat_2, 4);
     AE_L8X4F_IP(d_mat3, p_mat_3, 4);
     AE_LA8X4F_IP(d_vec, d_vec_la, p_vec_tmp);
-    d_mat0 = AE_SRAI16(d_mat0, 8);
-    d_mat1 = AE_SRAI16(d_mat1, 8);
-    d_mat2 = AE_SRAI16(d_mat2, 8);
-    d_mat3 = AE_SRAI16(d_mat3, 8);
     d_vec = AE_SRAI16(d_vec, 8);
 #endif
-    d_mat0 = AE_ADD16(d_mat0, AE_MOVDA16(mat_zero_bias));
-    d_mat1 = AE_ADD16(d_mat1, AE_MOVDA16(mat_zero_bias));
-    d_mat2 = AE_ADD16(d_mat2, AE_MOVDA16(mat_zero_bias));
-    d_mat3 = AE_ADD16(d_mat3, AE_MOVDA16(mat_zero_bias));
     d_vec = AE_ADD16(d_vec, AE_MOVDA16(vec_zero_bias));
 
     AE_MULAAAAQ16(out_0, d_mat0, d_vec);
@@ -245,16 +245,8 @@ static inline void _xa_nn_dot_product_4_rows_1_vec_mat_aligned_vec_unaligned
     AE_L8X4F_IP(d_mat2, p_mat_2, 4);
     AE_L8X4F_IP(d_mat3, p_mat_3, 4);
     AE_LA8X4F_IP(d_vec, d_vec_la, p_vec_tmp);
-    d_mat0 = AE_SRAI16(d_mat0, 8);
-    d_mat1 = AE_SRAI16(d_mat1, 8);
-    d_mat2 = AE_SRAI16(d_mat2, 8);
-    d_mat3 = AE_SRAI16(d_mat3, 8);
     d_vec = AE_SRAI16(d_vec, 8);
 #endif
-    d_mat0 = AE_ADD16(d_mat0, AE_MOVDA16(mat_zero_bias));
-    d_mat1 = AE_ADD16(d_mat1, AE_MOVDA16(mat_zero_bias));
-    d_mat2 = AE_ADD16(d_mat2, AE_MOVDA16(mat_zero_bias));
-    d_mat3 = AE_ADD16(d_mat3, AE_MOVDA16(mat_zero_bias));
     d_vec = AE_ADD16(d_vec, AE_MOVDA16(vec_zero_bias));
 
     // nullify the trailing elements in d_vec to ignore trailing columns
@@ -266,6 +258,13 @@ static inline void _xa_nn_dot_product_4_rows_1_vec_mat_aligned_vec_unaligned
     AE_MULAAAAQ16(out_3, d_mat3, d_vec);
   }
 
+#if !XCHAL_HAVE_HIFI1
+  out_0 = AE_SRAI64(out_0, 8);
+  out_1 = AE_SRAI64(out_1, 8);
+  out_2 = AE_SRAI64(out_2, 8);
+  out_3 = AE_SRAI64(out_3, 8);
+#endif
+
   acc_row0_vec0 = AE_SEL32_LL(AE_MOVINT32X2_FROMINT64(out_0), AE_MOVINT32X2_FROMINT64(out_1));
   acc_row1_vec0 = AE_SEL32_LL(AE_MOVINT32X2_FROMINT64(out_2), AE_MOVINT32X2_FROMINT64(out_3));
 
@@ -280,7 +279,6 @@ static inline void _xa_nn_dot_product_4_rows_1_vecs_offset_aligned
     ,const WORD8*      p_vec_0
     ,WORD32      cols1
     ,WORD32      row_stride1
-    ,WORD32      mat_zero_bias
     ,WORD32      vec_zero_bias)
 {
   int c_itr = 0;
@@ -302,12 +300,21 @@ static inline void _xa_nn_dot_product_4_rows_1_vecs_offset_aligned
   ae_int32x2 acc_row0_vec0 = *out_0_0;
   ae_int32x2 acc_row1_vec0 = *out_1_0;
 
+  out_0 = AE_CVT64F32_H(acc_row0_vec0);
   out_1 = AE_CVT64F32_L(acc_row0_vec0);
+  out_2 = AE_CVT64F32_H(acc_row1_vec0);
   out_3 = AE_CVT64F32_L(acc_row1_vec0);
-  out_0 = AE_SRAI64(AE_MOVINT64_FROMINT32X2(acc_row0_vec0), 32);
+#if XCHAL_HAVE_HIFI1
+  out_0 = AE_SRAI64(out_0, 32);
   out_1 = AE_SRAI64(out_1, 32);
-  out_2 = AE_SRAI64(AE_MOVINT64_FROMINT32X2(acc_row1_vec0), 32);
+  out_2 = AE_SRAI64(out_2, 32);
   out_3 = AE_SRAI64(out_3, 32);
+#else
+  out_0 = AE_SRAI64(out_0, 32-8);
+  out_1 = AE_SRAI64(out_1, 32-8);
+  out_2 = AE_SRAI64(out_2, 32-8);
+  out_3 = AE_SRAI64(out_3, 32-8);
+#endif
 
   PRIME_8X4F(p_mat_0_tmp, d_mat0_la);
   PRIME_8X4F(p_mat_1_tmp, d_mat1_la);
@@ -329,16 +336,9 @@ static inline void _xa_nn_dot_product_4_rows_1_vecs_offset_aligned
     AE_LA8X4F_IP(d_mat2, d_mat2_la, p_mat_2_tmp);
     AE_LA8X4F_IP(d_mat3, d_mat3_la, p_mat_3_tmp);
     AE_LA8X4F_IP(d_vec, d_vec_la, p_vec_tmp);
-    d_mat0 = AE_SRAI16(d_mat0, 8);
-    d_mat1 = AE_SRAI16(d_mat1, 8);
-    d_mat2 = AE_SRAI16(d_mat2, 8);
-    d_mat3 = AE_SRAI16(d_mat3, 8);
     d_vec = AE_SRAI16(d_vec, 8);
 #endif
-    d_mat0 = AE_ADD16(d_mat0, AE_MOVDA16(mat_zero_bias));
-    d_mat1 = AE_ADD16(d_mat1, AE_MOVDA16(mat_zero_bias));
-    d_mat2 = AE_ADD16(d_mat2, AE_MOVDA16(mat_zero_bias));
-    d_mat3 = AE_ADD16(d_mat3, AE_MOVDA16(mat_zero_bias));
+
     d_vec = AE_ADD16(d_vec, AE_MOVDA16(vec_zero_bias));
 
     AE_MULAAAAQ16(out_0, d_mat0, d_vec);
@@ -347,6 +347,12 @@ static inline void _xa_nn_dot_product_4_rows_1_vecs_offset_aligned
     AE_MULAAAAQ16(out_3, d_mat3, d_vec);
   }
 
+#if !XCHAL_HAVE_HIFI1
+  out_0 = AE_SRAI64(out_0, 8);
+  out_1 = AE_SRAI64(out_1, 8);
+  out_2 = AE_SRAI64(out_2, 8);
+  out_3 = AE_SRAI64(out_3, 8);
+#endif
   acc_row0_vec0 = AE_SEL32_LL(AE_MOVINT32X2_FROMINT64(out_0), AE_MOVINT32X2_FROMINT64(out_1));
   acc_row1_vec0 = AE_SEL32_LL(AE_MOVINT32X2_FROMINT64(out_2), AE_MOVINT32X2_FROMINT64(out_3));
 
@@ -367,10 +373,6 @@ static inline void _xa_nn_dot_product_4_rows_1_vecs_offset_aligned
       d_mat2 = AE_MOVDA16(*(p_mat_2_rem+rem));
       d_mat3 = AE_MOVDA16(*(p_mat_3_rem+rem));
       d_vec = AE_MOVDA16(*(p_vec_rem+rem));
-      d_mat0 = AE_ADD16(d_mat0, AE_MOVDA16(mat_zero_bias));
-      d_mat1 = AE_ADD16(d_mat1, AE_MOVDA16(mat_zero_bias));
-      d_mat2 = AE_ADD16(d_mat2, AE_MOVDA16(mat_zero_bias));
-      d_mat3 = AE_ADD16(d_mat3, AE_MOVDA16(mat_zero_bias));
       d_vec = AE_ADD16(d_vec, AE_MOVDA16(vec_zero_bias));
       d_mat = AE_SEL16_7531(AE_SEL16_7531(d_mat0, d_mat1), AE_SEL16_7531(d_mat2, d_mat3));
       AE_MULA16X4(acc_row0_vec0, acc_row1_vec0, d_mat, d_vec);
@@ -381,7 +383,6 @@ static inline void _xa_nn_dot_product_4_rows_1_vecs_offset_aligned
 }
 
 #if XCHAL_HAVE_HIFI1
-
 static inline void _xa_nn_dot_product_4_rows_1_vec_mat_aligned_vec_aligned
     (ae_int32x2*  out_0_0
     ,ae_int32x2*  out_1_0
@@ -389,7 +390,6 @@ static inline void _xa_nn_dot_product_4_rows_1_vec_mat_aligned_vec_aligned
     ,const WORD8* p_vec_0
     ,WORD32       cols1
     ,WORD32       row_stride1
-    ,WORD32       mat_zero_bias
     ,WORD32       vec_zero_bias)
 {
   int c_itr = 0;
@@ -423,11 +423,6 @@ static inline void _xa_nn_dot_product_4_rows_1_vec_mat_aligned_vec_aligned
     d_mat2 =  AE_L8X4S_I(p_mat_2, 4);
     d_mat3 =  AE_L8X4S_I(p_mat_3, 4);
 
-    d_mat0 = AE_ADD16(d_mat0, AE_MOVDA16(mat_zero_bias));
-    d_mat1 = AE_ADD16(d_mat1, AE_MOVDA16(mat_zero_bias));
-    d_mat2 = AE_ADD16(d_mat2, AE_MOVDA16(mat_zero_bias));
-    d_mat3 = AE_ADD16(d_mat3, AE_MOVDA16(mat_zero_bias));
-
     d_vec = AE_L8X4S_I(p_vec, 4);
     d_vec = AE_ADD16(d_vec, AE_MOVDA16(vec_zero_bias));
 
@@ -441,11 +436,6 @@ static inline void _xa_nn_dot_product_4_rows_1_vec_mat_aligned_vec_aligned
     AE_L8X4S_IP(d_mat2,  p_mat_2, 8);
     AE_L8X4S_IP(d_mat3,  p_mat_3, 8);
 
-    d_mat0 = AE_ADD16(d_mat0, AE_MOVDA16(mat_zero_bias));
-    d_mat1 = AE_ADD16(d_mat1, AE_MOVDA16(mat_zero_bias));
-    d_mat2 = AE_ADD16(d_mat2, AE_MOVDA16(mat_zero_bias));
-    d_mat3 = AE_ADD16(d_mat3, AE_MOVDA16(mat_zero_bias));
-
     AE_L8X4S_IP(d_vec, p_vec, 8);
     d_vec = AE_ADD16(d_vec, AE_MOVDA16(vec_zero_bias));
 
@@ -465,10 +455,6 @@ static inline void _xa_nn_dot_product_4_rows_1_vec_mat_aligned_vec_aligned
     AE_L8X4S_IP(d_mat3,  p_mat_3, 4);
     AE_L8X4S_IP(d_vec, p_vec, 4);
 
-    d_mat0 = AE_ADD16(d_mat0, AE_MOVDA16(mat_zero_bias));
-    d_mat1 = AE_ADD16(d_mat1, AE_MOVDA16(mat_zero_bias));
-    d_mat2 = AE_ADD16(d_mat2, AE_MOVDA16(mat_zero_bias));
-    d_mat3 = AE_ADD16(d_mat3, AE_MOVDA16(mat_zero_bias));
     d_vec = AE_ADD16(d_vec, AE_MOVDA16(vec_zero_bias));
 
     AE_MULAAAAQ16(out_0, d_mat0, d_vec);
@@ -492,11 +478,6 @@ static inline void _xa_nn_dot_product_4_rows_1_vec_mat_aligned_vec_aligned
     AE_L8X4S_IP(d_mat3,  p_mat_3, 4);
     AE_L8X4S_IP(d_vec, p_vec, 4);
 
-    d_mat0 = AE_ADD16(d_mat0, AE_MOVDA16(mat_zero_bias));
-    d_mat1 = AE_ADD16(d_mat1, AE_MOVDA16(mat_zero_bias));
-    d_mat2 = AE_ADD16(d_mat2, AE_MOVDA16(mat_zero_bias));
-    d_mat3 = AE_ADD16(d_mat3, AE_MOVDA16(mat_zero_bias));
-
     d_vec = AE_ADD16(d_vec, AE_MOVDA16(vec_zero_bias));
 
     // nullify the trailing elements in d_vec to ignore trailing columns
@@ -514,6 +495,8 @@ static inline void _xa_nn_dot_product_4_rows_1_vec_mat_aligned_vec_aligned
 }
 
 #else
+
+#if XA_HAVE_HIFI3_CORE
 static inline void _xa_nn_dot_product_8_rows_1_vec_mat_aligned_vec_aligned
     (ae_int32x2*  out_0_0
     ,ae_int32x2*  out_1_0
@@ -523,7 +506,6 @@ static inline void _xa_nn_dot_product_8_rows_1_vec_mat_aligned_vec_aligned
     ,const WORD8* p_vec_0
     ,WORD32       cols1
     ,WORD32       row_stride1
-    ,WORD32       mat_zero_bias
     ,WORD32       vec_zero_bias)
 {
   int c_itr = 0;
@@ -551,14 +533,15 @@ static inline void _xa_nn_dot_product_8_rows_1_vec_mat_aligned_vec_aligned
   out_3 = AE_CVT64F32_L(acc_row1_vec0);
   out_5 = AE_CVT64F32_L(acc_row2_vec0);
   out_7 = AE_CVT64F32_L(acc_row3_vec0);
-  out_0 = AE_SRAI64(AE_MOVINT64_FROMINT32X2(acc_row0_vec0), 32);
-  out_1 = AE_SRAI64(out_1, 32);
-  out_2 = AE_SRAI64(AE_MOVINT64_FROMINT32X2(acc_row1_vec0), 32);
-  out_3 = AE_SRAI64(out_3, 32);
-  out_4 = AE_SRAI64(AE_MOVINT64_FROMINT32X2(acc_row2_vec0), 32);
-  out_5 = AE_SRAI64(out_5, 32);
-  out_6 = AE_SRAI64(AE_MOVINT64_FROMINT32X2(acc_row3_vec0), 32);
-  out_7 = AE_SRAI64(out_7, 32);
+
+  out_0 = AE_SRAI64(AE_MOVINT64_FROMINT32X2(acc_row0_vec0), 24);
+  out_1 = AE_SRAI64(out_1, 24);
+  out_2 = AE_SRAI64(AE_MOVINT64_FROMINT32X2(acc_row1_vec0), 24);
+  out_3 = AE_SRAI64(out_3, 24);
+  out_4 = AE_SRAI64(AE_MOVINT64_FROMINT32X2(acc_row2_vec0), 24);
+  out_5 = AE_SRAI64(out_5, 24);
+  out_6 = AE_SRAI64(AE_MOVINT64_FROMINT32X2(acc_row3_vec0), 24);
+  out_7 = AE_SRAI64(out_7, 24);
 
   for(c_itr = 0; c_itr < cols1 >> 3; c_itr++)
   {
@@ -582,24 +565,6 @@ static inline void _xa_nn_dot_product_8_rows_1_vec_mat_aligned_vec_aligned
     d_mat3 =  AE_L8X4F_I(p_mat_3, 4);
     AE_L8X4F_IP(d_mat31,  p_mat_3, 8);
 
-    d_mat0 = AE_SRAI16(d_mat0, 8);
-    d_mat1 = AE_SRAI16(d_mat1, 8);
-    d_mat2 = AE_SRAI16(d_mat2, 8);
-    d_mat3 = AE_SRAI16(d_mat3, 8);
-    d_mat01 = AE_SRAI16(d_mat01, 8);
-    d_mat11 = AE_SRAI16(d_mat11, 8);
-    d_mat21 = AE_SRAI16(d_mat21, 8);
-    d_mat31 = AE_SRAI16(d_mat31, 8);
-
-    d_mat0 =  AE_ADD16(d_mat0, AE_MOVDA16(mat_zero_bias));
-    d_mat1 =  AE_ADD16(d_mat1, AE_MOVDA16(mat_zero_bias));
-    d_mat2 =  AE_ADD16(d_mat2, AE_MOVDA16(mat_zero_bias));
-    d_mat3 =  AE_ADD16(d_mat3, AE_MOVDA16(mat_zero_bias));
-    d_mat01 = AE_ADD16(d_mat01, AE_MOVDA16(mat_zero_bias));
-    d_mat11 = AE_ADD16(d_mat11, AE_MOVDA16(mat_zero_bias));
-    d_mat21 = AE_ADD16(d_mat21, AE_MOVDA16(mat_zero_bias));
-    d_mat31 = AE_ADD16(d_mat31, AE_MOVDA16(mat_zero_bias));
-
     AE_MULAAAAQ16(out_0, d_mat0, d_vec);
     AE_MULAAAAQ16(out_1, d_mat1, d_vec);
     AE_MULAAAAQ16(out_2, d_mat2, d_vec);
@@ -615,7 +580,7 @@ static inline void _xa_nn_dot_product_8_rows_1_vec_mat_aligned_vec_aligned
 
   for(c_itr = 0; c_itr < cols1 >> 3; c_itr++)
   {
-    ae_int16x4 d_mat01, d_mat11, d_mat21, d_mat31, d_vec1;
+    ae_int16x4 d_mat41, d_mat51, d_mat61, d_mat71, d_vec1;
 
     d_vec = AE_L8X4F_I(p_vec, 4);
     AE_L8X4F_IP(d_vec1, p_vec, 8);
@@ -626,42 +591,24 @@ static inline void _xa_nn_dot_product_8_rows_1_vec_mat_aligned_vec_aligned
     d_vec1 = AE_SRAI16(d_vec1, 8);
     d_vec1 = AE_ADD16(d_vec1, AE_MOVDA16(vec_zero_bias));
 
-    d_mat0 =  AE_L8X4F_I(p_mat_4, 4);
-    AE_L8X4F_IP(d_mat01,  p_mat_4, 8);
-    d_mat1 =  AE_L8X4F_I(p_mat_5, 4);
-    AE_L8X4F_IP(d_mat11,  p_mat_5, 8);
-    d_mat2 =  AE_L8X4F_I(p_mat_6, 4);
-    AE_L8X4F_IP(d_mat21,  p_mat_6, 8);
-    d_mat3 =  AE_L8X4F_I(p_mat_7, 4);
-    AE_L8X4F_IP(d_mat31,  p_mat_7, 8);
-
-    d_mat0 = AE_SRAI16(d_mat0, 8);
-    d_mat1 = AE_SRAI16(d_mat1, 8);
-    d_mat2 = AE_SRAI16(d_mat2, 8);
-    d_mat3 = AE_SRAI16(d_mat3, 8);
-    d_mat01 = AE_SRAI16(d_mat01, 8);
-    d_mat11 = AE_SRAI16(d_mat11, 8);
-    d_mat21 = AE_SRAI16(d_mat21, 8);
-    d_mat31 = AE_SRAI16(d_mat31, 8);
-
-    d_mat0 =  AE_ADD16(d_mat0, AE_MOVDA16(mat_zero_bias));
-    d_mat1 =  AE_ADD16(d_mat1, AE_MOVDA16(mat_zero_bias));
-    d_mat2 =  AE_ADD16(d_mat2, AE_MOVDA16(mat_zero_bias));
-    d_mat3 =  AE_ADD16(d_mat3, AE_MOVDA16(mat_zero_bias));
-    d_mat01 = AE_ADD16(d_mat01, AE_MOVDA16(mat_zero_bias));
-    d_mat11 = AE_ADD16(d_mat11, AE_MOVDA16(mat_zero_bias));
-    d_mat21 = AE_ADD16(d_mat21, AE_MOVDA16(mat_zero_bias));
-    d_mat31 = AE_ADD16(d_mat31, AE_MOVDA16(mat_zero_bias));
-
-    AE_MULAAAAQ16(out_4, d_mat0, d_vec);
-    AE_MULAAAAQ16(out_5, d_mat1, d_vec);
-    AE_MULAAAAQ16(out_6, d_mat2, d_vec);
-    AE_MULAAAAQ16(out_7, d_mat3, d_vec);
-
-    AE_MULAAAAQ16(out_4, d_mat01, d_vec1);
-    AE_MULAAAAQ16(out_5, d_mat11, d_vec1);
-    AE_MULAAAAQ16(out_6, d_mat21, d_vec1);
-    AE_MULAAAAQ16(out_7, d_mat31, d_vec1);
+    d_mat4 =  AE_L8X4F_I(p_mat_4, 4);
+    AE_L8X4F_IP(d_mat41,  p_mat_4, 8);
+    d_mat5 =  AE_L8X4F_I(p_mat_5, 4);
+    AE_L8X4F_IP(d_mat51,  p_mat_5, 8);
+    d_mat6 =  AE_L8X4F_I(p_mat_6, 4);
+    AE_L8X4F_IP(d_mat61,  p_mat_6, 8);
+    d_mat7 =  AE_L8X4F_I(p_mat_7, 4);
+    AE_L8X4F_IP(d_mat71,  p_mat_7, 8);
+
+    AE_MULAAAAQ16(out_4, d_mat4, d_vec);
+    AE_MULAAAAQ16(out_5, d_mat5, d_vec);
+    AE_MULAAAAQ16(out_6, d_mat6, d_vec);
+    AE_MULAAAAQ16(out_7, d_mat7, d_vec);
+
+    AE_MULAAAAQ16(out_4, d_mat41, d_vec1);
+    AE_MULAAAAQ16(out_5, d_mat51, d_vec1);
+    AE_MULAAAAQ16(out_6, d_mat61, d_vec1);
+    AE_MULAAAAQ16(out_7, d_mat71, d_vec1);
   }
 
   /* Remaining 4 elements of multiple of 4 length */
@@ -676,23 +623,145 @@ static inline void _xa_nn_dot_product_8_rows_1_vec_mat_aligned_vec_aligned
     AE_L8X4F_IP(d_mat6,  p_mat_6, 4);
     AE_L8X4F_IP(d_mat7,  p_mat_7, 4);
 
-    d_mat0 = AE_SRAI16(d_mat0, 8);
-    d_mat1 = AE_SRAI16(d_mat1, 8);
-    d_mat2 = AE_SRAI16(d_mat2, 8);
-    d_mat3 = AE_SRAI16(d_mat3, 8);
-    d_mat4 = AE_SRAI16(d_mat4, 8);
-    d_mat5 = AE_SRAI16(d_mat5, 8);
-    d_mat6 = AE_SRAI16(d_mat6, 8);
-    d_mat7 = AE_SRAI16(d_mat7, 8);
-
-    d_mat0 = AE_ADD16(d_mat0, AE_MOVDA16(mat_zero_bias));
-    d_mat1 = AE_ADD16(d_mat1, AE_MOVDA16(mat_zero_bias));
-    d_mat2 = AE_ADD16(d_mat2, AE_MOVDA16(mat_zero_bias));
-    d_mat3 = AE_ADD16(d_mat3, AE_MOVDA16(mat_zero_bias));
-    d_mat4 = AE_ADD16(d_mat4, AE_MOVDA16(mat_zero_bias));
-    d_mat5 = AE_ADD16(d_mat5, AE_MOVDA16(mat_zero_bias));
-    d_mat6 = AE_ADD16(d_mat6, AE_MOVDA16(mat_zero_bias));
-    d_mat7 = AE_ADD16(d_mat7, AE_MOVDA16(mat_zero_bias));
+    AE_L8X4F_IP(d_vec, p_vec, 4);
+    d_vec = AE_SRAI16(d_vec, 8);
+    d_vec = AE_ADD16(d_vec, AE_MOVDA16(vec_zero_bias));
+
+    AE_MULAAAAQ16(out_0, d_mat0, d_vec);
+    AE_MULAAAAQ16(out_1, d_mat1, d_vec);
+    AE_MULAAAAQ16(out_2, d_mat2, d_vec);
+    AE_MULAAAAQ16(out_3, d_mat3, d_vec);
+    AE_MULAAAAQ16(out_4, d_mat4, d_vec);
+    AE_MULAAAAQ16(out_5, d_mat5, d_vec);
+    AE_MULAAAAQ16(out_6, d_mat6, d_vec);
+    AE_MULAAAAQ16(out_7, d_mat7, d_vec);
+  }
+
+  out_0 = AE_SRAI64(out_0, 8);
+  out_1 = AE_SRAI64(out_1, 8);
+  out_2 = AE_SRAI64(out_2, 8);
+  out_3 = AE_SRAI64(out_3, 8);
+  out_4 = AE_SRAI64(out_4, 8);
+  out_5 = AE_SRAI64(out_5, 8);
+  out_6 = AE_SRAI64(out_6, 8);
+  out_7 = AE_SRAI64(out_7, 8);
+  acc_row0_vec0 = AE_SEL32_LL(AE_MOVINT32X2_FROMINT64(out_0), AE_MOVINT32X2_FROMINT64(out_1));
+  acc_row1_vec0 = AE_SEL32_LL(AE_MOVINT32X2_FROMINT64(out_2), AE_MOVINT32X2_FROMINT64(out_3));
+  acc_row2_vec0 = AE_SEL32_LL(AE_MOVINT32X2_FROMINT64(out_4), AE_MOVINT32X2_FROMINT64(out_5));
+  acc_row3_vec0 = AE_SEL32_LL(AE_MOVINT32X2_FROMINT64(out_6), AE_MOVINT32X2_FROMINT64(out_7));
+  *out_0_0 = acc_row0_vec0;
+  *out_1_0 = acc_row1_vec0;
+  *out_2_0 = acc_row2_vec0;
+  *out_3_0 = acc_row3_vec0;
+}
+#else //XA_HAVE_HIFI3_CORE
+static inline void _xa_nn_dot_product_8_rows_1_vec_mat_aligned_vec_aligned
+    (ae_int32x2*  out_0_0
+    ,ae_int32x2*  out_1_0
+    ,ae_int32x2*  out_2_0
+    ,ae_int32x2*  out_3_0
+    ,const WORD8* p_mat_0
+    ,const WORD8* p_vec_0
+    ,WORD32       cols1
+    ,WORD32       row_stride1
+    ,WORD32       vec_zero_bias)
+{
+  int c_itr = 0;
+  ae_int16x4 d_mat0, d_mat1, d_mat2, d_mat3, d_vec;
+  ae_int16x4 d_mat4, d_mat5, d_mat6, d_mat7;
+  ae_int64 out_0, out_1, out_2, out_3;
+  ae_int64 out_4, out_5, out_6, out_7;
+
+  WORD8 *p_mat_1 = ((WORD8 *)p_mat_0 + row_stride1);
+  WORD8 *p_mat_2 = ((WORD8 *)p_mat_1 + row_stride1);
+  WORD8 *p_mat_3 = ((WORD8 *)p_mat_2 + row_stride1);
+  WORD8 *p_mat_4 = ((WORD8 *)p_mat_3 + row_stride1);
+  WORD8 *p_mat_5 = ((WORD8 *)p_mat_4 + row_stride1);
+  WORD8 *p_mat_6 = ((WORD8 *)p_mat_5 + row_stride1);
+  WORD8 *p_mat_7 = ((WORD8 *)p_mat_6 + row_stride1);
+
+  WORD8 *p_vec = (WORD8*)p_vec_0;
+
+  ae_int32x2 acc_row0_vec0 = *out_0_0;
+  ae_int32x2 acc_row1_vec0 = *out_1_0;
+  ae_int32x2 acc_row2_vec0 = *out_2_0;
+  ae_int32x2 acc_row3_vec0 = *out_3_0;
+
+  out_1 = AE_CVT64F32_L(acc_row0_vec0);
+  out_3 = AE_CVT64F32_L(acc_row1_vec0);
+  out_5 = AE_CVT64F32_L(acc_row2_vec0);
+  out_7 = AE_CVT64F32_L(acc_row3_vec0);
+
+  out_0 = AE_SRAI64(AE_MOVINT64_FROMINT32X2(acc_row0_vec0), 24);
+  out_1 = AE_SRAI64(out_1, 24);
+  out_2 = AE_SRAI64(AE_MOVINT64_FROMINT32X2(acc_row1_vec0), 24);
+  out_3 = AE_SRAI64(out_3, 24);
+  out_4 = AE_SRAI64(AE_MOVINT64_FROMINT32X2(acc_row2_vec0), 24);
+  out_5 = AE_SRAI64(out_5, 24);
+  out_6 = AE_SRAI64(AE_MOVINT64_FROMINT32X2(acc_row3_vec0), 24);
+  out_7 = AE_SRAI64(out_7, 24);
+
+  for(c_itr = 0; c_itr < cols1 >> 3; c_itr++)
+  {
+    ae_int16x4 d_mat01, d_mat11, d_mat21, d_mat31, d_vec1;
+    ae_int16x4 d_mat41, d_mat51, d_mat61, d_mat71;
+
+    d_vec = AE_L8X4F_I(p_vec, 4);
+    AE_L8X4F_IP(d_vec1, p_vec, 8);
+
+    d_vec = AE_SRAI16(d_vec, 8);
+    d_vec = AE_ADD16(d_vec, AE_MOVDA16(vec_zero_bias));
+
+    d_vec1 = AE_SRAI16(d_vec1, 8);
+    d_vec1 = AE_ADD16(d_vec1, AE_MOVDA16(vec_zero_bias));
+
+    d_mat0 =  AE_L8X4F_I(p_mat_0, 4);
+    AE_L8X4F_IP(d_mat01,  p_mat_0, 8);
+    d_mat1 =  AE_L8X4F_I(p_mat_1, 4);
+    AE_L8X4F_IP(d_mat11,  p_mat_1, 8);
+    d_mat2 =  AE_L8X4F_I(p_mat_2, 4);
+    AE_L8X4F_IP(d_mat21,  p_mat_2, 8);
+    d_mat3 =  AE_L8X4F_I(p_mat_3, 4);
+    AE_L8X4F_IP(d_mat31,  p_mat_3, 8);
+    d_mat4 =  AE_L8X4F_I(p_mat_4, 4);
+    AE_L8X4F_IP(d_mat41,  p_mat_4, 8);
+    d_mat5 =  AE_L8X4F_I(p_mat_5, 4);
+    AE_L8X4F_IP(d_mat51,  p_mat_5, 8);
+    d_mat6 =  AE_L8X4F_I(p_mat_6, 4);
+    AE_L8X4F_IP(d_mat61,  p_mat_6, 8);
+    d_mat7 =  AE_L8X4F_I(p_mat_7, 4);
+    AE_L8X4F_IP(d_mat71,  p_mat_7, 8);
+
+    AE_MULAAAAQ16(out_0, d_mat0, d_vec);
+    AE_MULAAAAQ16(out_1, d_mat1, d_vec);
+    AE_MULAAAAQ16(out_2, d_mat2, d_vec);
+    AE_MULAAAAQ16(out_3, d_mat3, d_vec);
+    AE_MULAAAAQ16(out_4, d_mat4, d_vec);
+    AE_MULAAAAQ16(out_5, d_mat5, d_vec);
+    AE_MULAAAAQ16(out_6, d_mat6, d_vec);
+    AE_MULAAAAQ16(out_7, d_mat7, d_vec);
+
+    AE_MULAAAAQ16(out_0, d_mat01, d_vec1);
+    AE_MULAAAAQ16(out_1, d_mat11, d_vec1);
+    AE_MULAAAAQ16(out_2, d_mat21, d_vec1);
+    AE_MULAAAAQ16(out_3, d_mat31, d_vec1);
+    AE_MULAAAAQ16(out_4, d_mat41, d_vec1);
+    AE_MULAAAAQ16(out_5, d_mat51, d_vec1);
+    AE_MULAAAAQ16(out_6, d_mat61, d_vec1);
+    AE_MULAAAAQ16(out_7, d_mat71, d_vec1);
+  }
+
+  /* Remaining 4 elements of multiple of 4 length */
+  if((c_itr << 3) < cols1)
+  {
+    AE_L8X4F_IP(d_mat0,  p_mat_0, 4);
+    AE_L8X4F_IP(d_mat1,  p_mat_1, 4);
+    AE_L8X4F_IP(d_mat2,  p_mat_2, 4);
+    AE_L8X4F_IP(d_mat3,  p_mat_3, 4);
+    AE_L8X4F_IP(d_mat4,  p_mat_4, 4);
+    AE_L8X4F_IP(d_mat5,  p_mat_5, 4);
+    AE_L8X4F_IP(d_mat6,  p_mat_6, 4);
+    AE_L8X4F_IP(d_mat7,  p_mat_7, 4);
 
     AE_L8X4F_IP(d_vec, p_vec, 4);
     d_vec = AE_SRAI16(d_vec, 8);
@@ -708,6 +777,14 @@ static inline void _xa_nn_dot_product_8_rows_1_vec_mat_aligned_vec_aligned
     AE_MULAAAAQ16(out_7, d_mat7, d_vec);
   }
 
+  out_0 = AE_SRAI64(out_0, 8);
+  out_1 = AE_SRAI64(out_1, 8);
+  out_2 = AE_SRAI64(out_2, 8);
+  out_3 = AE_SRAI64(out_3, 8);
+  out_4 = AE_SRAI64(out_4, 8);
+  out_5 = AE_SRAI64(out_5, 8);
+  out_6 = AE_SRAI64(out_6, 8);
+  out_7 = AE_SRAI64(out_7, 8);
   acc_row0_vec0 = AE_SEL32_LL(AE_MOVINT32X2_FROMINT64(out_0), AE_MOVINT32X2_FROMINT64(out_1));
   acc_row1_vec0 = AE_SEL32_LL(AE_MOVINT32X2_FROMINT64(out_2), AE_MOVINT32X2_FROMINT64(out_3));
   acc_row2_vec0 = AE_SEL32_LL(AE_MOVINT32X2_FROMINT64(out_4), AE_MOVINT32X2_FROMINT64(out_5));
@@ -718,6 +795,8 @@ static inline void _xa_nn_dot_product_8_rows_1_vec_mat_aligned_vec_aligned
   *out_3_0 = acc_row3_vec0;
 }
 
+#endif //XA_HAVE_HIFI3_CORE
+
 static inline void _xa_nn_dot_product_4_rows_1_vec_mat_aligned_vec_aligned
     (ae_int32x2*  out_0_0
     ,ae_int32x2*  out_1_0
@@ -725,7 +804,6 @@ static inline void _xa_nn_dot_product_4_rows_1_vec_mat_aligned_vec_aligned
     ,const WORD8* p_vec_0
     ,WORD32       cols1
     ,WORD32       row_stride1
-    ,WORD32       mat_zero_bias
     ,WORD32       vec_zero_bias)
 {
   int c_itr = 0;
@@ -743,10 +821,10 @@ static inline void _xa_nn_dot_product_4_rows_1_vec_mat_aligned_vec_aligned
 
   out_1 = AE_CVT64F32_L(acc_row0_vec0);
   out_3 = AE_CVT64F32_L(acc_row1_vec0);
-  out_0 = AE_SRAI64(AE_MOVINT64_FROMINT32X2(acc_row0_vec0), 32);
-  out_1 = AE_SRAI64(out_1, 32);
-  out_2 = AE_SRAI64(AE_MOVINT64_FROMINT32X2(acc_row1_vec0), 32);
-  out_3 = AE_SRAI64(out_3, 32);
+  out_0 = AE_SRAI64(AE_MOVINT64_FROMINT32X2(acc_row0_vec0), 24);
+  out_1 = AE_SRAI64(out_1, 24);
+  out_2 = AE_SRAI64(AE_MOVINT64_FROMINT32X2(acc_row1_vec0), 24);
+  out_3 = AE_SRAI64(out_3, 24);
   /* 8 columns at a time */
   for(c_itr = 0; c_itr < cols1 >> 3; c_itr++)
   {
@@ -755,15 +833,6 @@ static inline void _xa_nn_dot_product_4_rows_1_vec_mat_aligned_vec_aligned
     d_mat2 =  AE_L8X4F_I(p_mat_2, 4);
     d_mat3 =  AE_L8X4F_I(p_mat_3, 4);
 
-    d_mat0 = AE_SRAI16(d_mat0, 8);
-    d_mat1 = AE_SRAI16(d_mat1, 8);
-    d_mat2 = AE_SRAI16(d_mat2, 8);
-    d_mat3 = AE_SRAI16(d_mat3, 8);
-    d_mat0 = AE_ADD16(d_mat0, AE_MOVDA16(mat_zero_bias));
-    d_mat1 = AE_ADD16(d_mat1, AE_MOVDA16(mat_zero_bias));
-    d_mat2 = AE_ADD16(d_mat2, AE_MOVDA16(mat_zero_bias));
-    d_mat3 = AE_ADD16(d_mat3, AE_MOVDA16(mat_zero_bias));
-
     d_vec = AE_L8X4F_I(p_vec, 4);
     d_vec = AE_SRAI16(d_vec, 8);
     d_vec = AE_ADD16(d_vec, AE_MOVDA16(vec_zero_bias));
@@ -778,15 +847,6 @@ static inline void _xa_nn_dot_product_4_rows_1_vec_mat_aligned_vec_aligned
     AE_L8X4F_IP(d_mat2,  p_mat_2, 8);
     AE_L8X4F_IP(d_mat3,  p_mat_3, 8);
 
-    d_mat0 = AE_SRAI16(d_mat0, 8);
-    d_mat1 = AE_SRAI16(d_mat1, 8);
-    d_mat2 = AE_SRAI16(d_mat2, 8);
-    d_mat3 = AE_SRAI16(d_mat3, 8);
-    d_mat0 = AE_ADD16(d_mat0, AE_MOVDA16(mat_zero_bias));
-    d_mat1 = AE_ADD16(d_mat1, AE_MOVDA16(mat_zero_bias));
-    d_mat2 = AE_ADD16(d_mat2, AE_MOVDA16(mat_zero_bias));
-    d_mat3 = AE_ADD16(d_mat3, AE_MOVDA16(mat_zero_bias));
-
     AE_L8X4F_IP(d_vec, p_vec, 8);
     d_vec = AE_SRAI16(d_vec, 8);
     d_vec = AE_ADD16(d_vec, AE_MOVDA16(vec_zero_bias));
@@ -807,16 +867,6 @@ static inline void _xa_nn_dot_product_4_rows_1_vec_mat_aligned_vec_aligned
     AE_L8X4F_IP(d_mat3,  p_mat_3, 4);
     AE_L8X4F_IP(d_vec, p_vec, 4);
 
-    d_mat0 = AE_SRAI16(d_mat0, 8);
-    d_mat1 = AE_SRAI16(d_mat1, 8);
-    d_mat2 = AE_SRAI16(d_mat2, 8);
-    d_mat3 = AE_SRAI16(d_mat3, 8);
-
-    d_mat0 = AE_ADD16(d_mat0, AE_MOVDA16(mat_zero_bias));
-    d_mat1 = AE_ADD16(d_mat1, AE_MOVDA16(mat_zero_bias));
-    d_mat2 = AE_ADD16(d_mat2, AE_MOVDA16(mat_zero_bias));
-    d_mat3 = AE_ADD16(d_mat3, AE_MOVDA16(mat_zero_bias));
-
     d_vec = AE_SRAI16(d_vec, 8);
     d_vec = AE_ADD16(d_vec, AE_MOVDA16(vec_zero_bias));
 
@@ -841,16 +891,6 @@ static inline void _xa_nn_dot_product_4_rows_1_vec_mat_aligned_vec_aligned
     AE_L8X4F_IP(d_mat3,  p_mat_3, 4);
     AE_L8X4F_IP(d_vec, p_vec, 4);
 
-    d_mat0 = AE_SRAI16(d_mat0, 8);
-    d_mat1 = AE_SRAI16(d_mat1, 8);
-    d_mat2 = AE_SRAI16(d_mat2, 8);
-    d_mat3 = AE_SRAI16(d_mat3, 8);
-
-    d_mat0 = AE_ADD16(d_mat0, AE_MOVDA16(mat_zero_bias));
-    d_mat1 = AE_ADD16(d_mat1, AE_MOVDA16(mat_zero_bias));
-    d_mat2 = AE_ADD16(d_mat2, AE_MOVDA16(mat_zero_bias));
-    d_mat3 = AE_ADD16(d_mat3, AE_MOVDA16(mat_zero_bias));
-
     d_vec = AE_SRAI16(d_vec, 8);
     d_vec = AE_ADD16(d_vec, AE_MOVDA16(vec_zero_bias));
 
@@ -863,6 +903,10 @@ static inline void _xa_nn_dot_product_4_rows_1_vec_mat_aligned_vec_aligned
     AE_MULAAAAQ16(out_3, d_mat3, d_vec);
   }
 
+  out_0 = AE_SRAI64(out_0, 8);
+  out_1 = AE_SRAI64(out_1, 8);
+  out_2 = AE_SRAI64(out_2, 8);
+  out_3 = AE_SRAI64(out_3, 8);
   acc_row0_vec0 = AE_SEL32_LL(AE_MOVINT32X2_FROMINT64(out_0), AE_MOVINT32X2_FROMINT64(out_1));
   acc_row1_vec0 = AE_SEL32_LL(AE_MOVINT32X2_FROMINT64(out_2), AE_MOVINT32X2_FROMINT64(out_3));
   *out_0_0 = acc_row0_vec0;
@@ -876,7 +920,6 @@ static inline void _xa_nn_dot_product_1_rows_1_vecs_aligned
      const WORD8*   p_mat_0,
      const WORD8*   p_vec_0,
      WORD32         cols1,
-     WORD32         mat_zero_bias,
      WORD32         vec_zero_bias)
 {
   int c_itr = 0;
@@ -895,7 +938,7 @@ static inline void _xa_nn_dot_product_1_rows_1_vecs_aligned
 
   WORD32 rem_elm_acc = 0;
   ae_int16x4 vec_zb = AE_MOVDA16(vec_zero_bias);
-  ae_int16x4 mat_zb = AE_MOVDA16(mat_zero_bias);
+
   // 4 columns per iteration
   for( ; c_itr<cols1/4; c_itr++)
   {
@@ -908,7 +951,7 @@ static inline void _xa_nn_dot_product_1_rows_1_vecs_aligned
     d_mat = AE_SRAI16(d_mat, 8);
     d_vec = AE_SRAI16(d_vec, 8);
 #endif
-    d_mat = AE_ADD16(d_mat, mat_zb);
+
     d_vec = AE_ADD16(d_vec, vec_zb);
 
     AE_MULA16X4(acc_part_01, acc_part_23, d_mat, d_vec);
@@ -924,7 +967,7 @@ static inline void _xa_nn_dot_product_1_rows_1_vecs_aligned
 
   // remaining columns
   for(c_itr *= 4; c_itr<cols1; c_itr++){
-    rem_elm_acc += (*p_mat + mat_zero_bias) * (*p_vec + vec_zero_bias);
+    rem_elm_acc += (*p_mat) * (*p_vec + vec_zero_bias);
     p_mat++, p_vec++;
   }
 
@@ -939,7 +982,6 @@ static inline void _xa_nn_dot_product_1_rows_1_vecs_unaligned
     ,const WORD8*      p_mat_0
     ,const WORD8*      p_vec_0
     ,WORD32      cols1
-    ,WORD32      mat_zero_bias
     ,WORD32      vec_zero_bias)
 {
   int c_itr = 0;
@@ -957,13 +999,48 @@ static inline void _xa_nn_dot_product_1_rows_1_vecs_unaligned
     d_mat = AE_MOVDA16(*(((WORD8 *)p_mat_0)+c_itr));
     d_vec = AE_MOVDA16(*(((WORD8 *)p_vec_0)+c_itr));
 #endif
-    d_mat = AE_ADD16(d_mat, AE_MOVDA16(mat_zero_bias));
     d_vec = AE_ADD16(d_vec, AE_MOVDA16(vec_zero_bias));
     AE_MULA16X4(d_out, d_tmp, d_mat, d_vec);
   }
   *out_0_0 = d_out;
 }
 
+/* Following kernel calculates contribution of matrix zero-biases towards final sum */
+static WORD32 internal_calc_mzbsum(WORD32 mat_zero_bias, WORD32 vec_zero_bias, const WORD8 * __restrict__ p_vec, int cols1)
+{
+  if(mat_zero_bias == 0){
+    return 0;
+  }
+
+  WORD32 sum_mzb32 = 0, c_itr;
+  WORD32 preloop_cnt = (4 - ((unsigned)p_vec-(((unsigned)p_vec)&~0x3))) & 0x03;
+  if(preloop_cnt > cols1) { preloop_cnt = 0;}
+  cols1 = cols1 - preloop_cnt;
+
+  for(c_itr = 0; c_itr < preloop_cnt; c_itr++){
+    int vecval = *p_vec++;
+    sum_mzb32 += (vecval+vec_zero_bias)*mat_zero_bias;
+  }
+
+  WORD64 sum_mzb = (WORD64)sum_mzb32;
+  ae_int16x4 mzb_16x4 = AE_MOVDA16(mat_zero_bias);
+  ae_int16x4 d_vec0;
+
+  for(c_itr = 0; c_itr < cols1>>2; c_itr++){
+    AE_L8X4F_IP(d_vec0, p_vec, 4);
+    d_vec0 = AE_SRAI16(d_vec0, 8);
+    d_vec0 = AE_ADD16(d_vec0, AE_MOVDA16(vec_zero_bias));
+    AE_MULAAAAQ16(sum_mzb, mzb_16x4, d_vec0);
+  }
+  sum_mzb32 = AE_MOVINT32X2_FROMINT64(sum_mzb);
+
+  for(c_itr = 0; c_itr < (cols1&0x3); c_itr++){
+    int vecval = *p_vec++;
+    sum_mzb32 += (vecval+vec_zero_bias)*mat_zero_bias;
+  }
+  return sum_mzb32;
+}
+
 /*  This kernel performs the following dual mat*vec op
  *    p_out = (mat1+mat1_zero_bias)*(vec1+vec1_zero_bias) +
  *            (mat2+mat2_zero_bias)*(vec2+vec2_zero_bias) +
@@ -1016,25 +1093,25 @@ WORD32 xa_nn_matXvec_asym8sxasym8s_asym8s(
     /* Basic Parameter checks */
     XA_NNLIB_ARG_CHK_COND((cols2 <= 0), -1);
     XA_NNLIB_ARG_CHK_COND((row_stride2 < cols2), -1);
-    XA_NNLIB_ARG_CHK_COND((vec2_zero_bias < -127 || vec2_zero_bias > 128), -1);
+    XA_NNLIB_ARG_CHK_COND((vec2_zero_bias < -127 || vec2_zero_bias > 128), -1);
   }
-  int m_itr = 0;
-  /* Assign initial value so this value will be used in trailing loop */
+
+  int m_itr=0;
   ae_int32x2 max_int8 = AE_MOVDA32(127);
   ae_int32x2 min_int8 = AE_MOVDA32(-128);
+
   /* Shifts to match with Tensorflow */
   int left_shift, right_shift;
 
 #if TFLITE_SINGLE_ROUNDING
   left_shift = out_shift;
-  right_shift = out_shift;
-  /* Single rounding macro doesn't need two shifts so this is not used */
+   /* Single rounding macro doesn't need two shifts so this is not used */
   (void)right_shift;
 #else /* #if TFLITE_SINGLE_ROUNDING */
   left_shift = out_shift<0?0:out_shift;
   right_shift = out_shift>0?0:-out_shift;
 #endif /* #if TFLITE_SINGLE_ROUNDING */
-  
+
   int bias_flag = 0;
   ae_valign bias_valign;
   if(p_bias != NULL)
@@ -1043,6 +1120,7 @@ WORD32 xa_nn_matXvec_asym8sxasym8s_asym8s(
     bias_flag = 1;
   }
 
+
   /* If p_mat2 is not NULL, then we are doing a dual mat*vec operation
    *   p_out = (mat1+mat1_zero_bias)*(vec1+vec1_zero_bias) +
    *           (mat2+mat2_zero_bias)*(vec2+vec2_zero_bias) +
@@ -1050,6 +1128,11 @@ WORD32 xa_nn_matXvec_asym8sxasym8s_asym8s(
    */
   if(p_mat2 != NULL)
   {
+    WORD32 mat1_zb_sum =  internal_calc_mzbsum(mat1_zero_bias, vec1_zero_bias, p_vec1, cols1);
+    WORD32 mat2_zb_sum =  internal_calc_mzbsum(mat2_zero_bias, vec2_zero_bias, p_vec2, cols2);
+    ae_int32x2 mat1_zb_sumx2 = mat1_zb_sum;
+    ae_int32x2 mat2_zb_sumx2 = mat2_zb_sum;
+
     // Initialize function pointers for dot product of 1R and 1C
     _dot_prod_1_rows_1_vecs_kernel
       mat1vec1_1R1C_dotprod_func = _xa_nn_dot_product_1_rows_1_vecs_unaligned,
@@ -1092,15 +1175,16 @@ WORD32 xa_nn_matXvec_asym8sxasym8s_asym8s(
     ae_int32x2 out_01 = 0, out_23 = 0;
 #if XCHAL_HAVE_HIFI1
     ae_valign align_out = AE_ZALIGN64();
+    ae_int16x4 out_0123;
 #endif
 
     // 4 rows per iteration
-    for(m_itr = 0; m_itr < ((rows>>2)<<2) ; m_itr+=4) {
+    for(m_itr = 0; m_itr < (rows/4)*4 ; m_itr+=4) {
         
       /* Load bias in the accumulator */
       if(bias_flag) {
         AE_LA32X2_IP(out_01, bias_valign, (ae_int32x2 *)p_bias);
-        AE_LA32X2_IP(out_23, bias_valign, (ae_int32x2 *)p_bias);   
+        AE_LA32X2_IP(out_23, bias_valign, (ae_int32x2 *)p_bias);
       }
 
       mat1vec1_4R1C_dotprod_func(
@@ -1109,18 +1193,22 @@ WORD32 xa_nn_matXvec_asym8sxasym8s_asym8s(
         p_vec1,
         cols1,
         row_stride1,
-        mat1_zero_bias,
         vec1_zero_bias);
 
+      out_01 = AE_ADD32(out_01,mat1_zb_sumx2);
+      out_23 = AE_ADD32(out_23,mat1_zb_sumx2);
+
       mat2vec2_4R1C_dotprod_func(
         &out_01, &out_23,
         p_mat2 + m_itr*row_stride2,
         p_vec2,
         cols2,
         row_stride2,
-        mat2_zero_bias,
         vec2_zero_bias);
 
+      out_01 = AE_ADD32(out_01,mat2_zb_sumx2);
+      out_23 = AE_ADD32(out_23,mat2_zb_sumx2);
+
       MPY_BY_QUANT_MULT_SLS_X2_OUT32(out_01, out_01, out_multiplier, left_shift, right_shift);
       MPY_BY_QUANT_MULT_SLS_X2_OUT32(out_23, out_23, out_multiplier, left_shift, right_shift);
 
@@ -1128,14 +1216,9 @@ WORD32 xa_nn_matXvec_asym8sxasym8s_asym8s(
       out_23 = AE_ADD32S(out_23, AE_MOVDA32(out_zero_bias));
 
 #if XCHAL_HAVE_HIFI1
-#if ( XCHAL_HW_VERSION >= RI9_HWVERSION )
-      ae_int8x8 out_0123 = AE_SAT8X4X32_H(out_01, out_23);
-      AE_SAV8X8_XP(out_0123, align_out, (ae_int8x8 *)p_out, 4);
-#else
-      ae_int16x4 out_0123 = AE_SAT16X4(out_01, out_23);
+      out_0123 = AE_SAT16X4(out_01, out_23);
       out_0123 = AE_SAT8S(out_0123);
       AE_SA8X4U_IP(out_0123, align_out, (ae_int32 *)p_out);
-#endif
 #else
       out_01 = AE_MAX32(out_01, min_int8);  out_01 = AE_MIN32(out_01, max_int8);
       out_23 = AE_MAX32(out_23, min_int8);  out_23 = AE_MIN32(out_23, max_int8);
@@ -1163,7 +1246,6 @@ WORD32 xa_nn_matXvec_asym8sxasym8s_asym8s(
 
       if(bias_flag)
       {
-        /* Load bias in the accumulator */
         AE_L32_IP(acc_row0_vec0, (ae_int32 *) p_bias, 4);
       }
 
@@ -1172,18 +1254,18 @@ WORD32 xa_nn_matXvec_asym8sxasym8s_asym8s(
          ,p_mat1_0
          ,p_vec1_0
          ,cols1
-         ,mat1_zero_bias
          ,vec1_zero_bias
         );
+      acc_row0_vec0 = AE_ADD32(acc_row0_vec0,mat1_zb_sumx2);
 
       mat2vec2_1R1C_dotprod_func
         (&acc_row0_vec0
          ,p_mat2_0
          ,p_vec2_0
          ,cols2
-         ,mat2_zero_bias
          ,vec2_zero_bias
         );
+      acc_row0_vec0 = AE_ADD32(acc_row0_vec0,mat2_zb_sumx2);
 
       MPY_BY_QUANT_MULT_SLS_X2_OUT32(acc_row0_vec0, acc_row0_vec0, out_multiplier, left_shift, right_shift);
       acc_row0_vec0 = AE_ADD32S(acc_row0_vec0, AE_MOVDA32(out_zero_bias));
@@ -1195,12 +1277,16 @@ WORD32 xa_nn_matXvec_asym8sxasym8s_asym8s(
   /* Else, this is a single mat*vec operation */
   else
   {
+    WORD32 mat1_zb_sum =  internal_calc_mzbsum(mat1_zero_bias, vec1_zero_bias, p_vec1, cols1);
+    ae_int32x2 mat1_zb_sumx2 = mat1_zb_sum;
+
     /* Matrix and vector (including other factors like dimensions/strides) are both aligned properly */
     if(((((unsigned)p_mat1) & 3) == 0) && ((((unsigned)p_vec1) & 3) == 0) && ((row_stride1 & 3) == 0) && ((cols1 & 3) == 0))
     {
       const WORD8 *p_mat1_0;
       const WORD8 *p_vec1_0;
-#if !XCHAL_HAVE_HIFI1 
+
+#if !XCHAL_HAVE_HIFI1
       for(m_itr = 0; m_itr < (rows & ~7); m_itr += 8)
       {
         ae_int32x2 acc_row0_vec0 = ZERO32;
@@ -1209,8 +1295,7 @@ WORD32 xa_nn_matXvec_asym8sxasym8s_asym8s(
         ae_int32x2 acc_row3_vec0 = ZERO32;
       
         if(bias_flag)
-        {
-          /* Load bias in the accumulator */
+        {
           AE_LA32X2_IP(acc_row0_vec0, bias_valign, (ae_int32x2 *)p_bias);
           AE_LA32X2_IP(acc_row1_vec0, bias_valign, (ae_int32x2 *)p_bias);
           AE_LA32X2_IP(acc_row2_vec0, bias_valign, (ae_int32x2 *)p_bias);
@@ -1229,9 +1314,13 @@ WORD32 xa_nn_matXvec_asym8sxasym8s_asym8s(
            ,p_vec1_0
            ,cols1
            ,row_stride1
-           ,mat1_zero_bias
            ,vec1_zero_bias
           );
+        acc_row0_vec0 = AE_ADD32(acc_row0_vec0, mat1_zb_sumx2);
+        acc_row1_vec0 = AE_ADD32(acc_row1_vec0, mat1_zb_sumx2);
+        acc_row2_vec0 = AE_ADD32(acc_row2_vec0, mat1_zb_sumx2);
+        acc_row3_vec0 = AE_ADD32(acc_row3_vec0, mat1_zb_sumx2);
+
         MPY_BY_QUANT_MULT_SLS_X2_OUT32(acc_row0_vec0, acc_row0_vec0, out_multiplier, left_shift, right_shift);
         MPY_BY_QUANT_MULT_SLS_X2_OUT32(acc_row1_vec0, acc_row1_vec0, out_multiplier, left_shift, right_shift);
         MPY_BY_QUANT_MULT_SLS_X2_OUT32(acc_row2_vec0, acc_row2_vec0, out_multiplier, left_shift, right_shift);
@@ -1259,11 +1348,11 @@ WORD32 xa_nn_matXvec_asym8sxasym8s_asym8s(
         *p_out++ = (WORD8)AE_MOVAD32_H(acc_row3_vec0);
         *p_out++ = (WORD8)AE_MOVAD32_L(acc_row3_vec0);
       }
-#endif 
+#endif
 #if XCHAL_HAVE_HIFI1
     ae_valign align_out = AE_ZALIGN64();
     ae_int16x4 rowvec01;
-    m_itr=0;
+	m_itr = 0;
 #endif
       for(; m_itr < (rows & ~3); m_itr += 4)
       {
@@ -1274,7 +1363,7 @@ WORD32 xa_nn_matXvec_asym8sxasym8s_asym8s(
         {
           /* Load bias in the accumulator */
           AE_LA32X2_IP(acc_row0_vec0, bias_valign, (ae_int32x2 *)p_bias);
-          AE_LA32X2_IP(acc_row1_vec0, bias_valign, (ae_int32x2 *)p_bias);  
+          AE_LA32X2_IP(acc_row1_vec0, bias_valign, (ae_int32x2 *)p_bias);
         }
       
         p_mat1_0 = (const WORD8 *)(p_mat1+(m_itr * row_stride1));
@@ -1287,9 +1376,10 @@ WORD32 xa_nn_matXvec_asym8sxasym8s_asym8s(
            ,p_vec1_0
            ,cols1
            ,row_stride1
-           ,mat1_zero_bias
            ,vec1_zero_bias
           );
+        acc_row0_vec0 = AE_ADD32(acc_row0_vec0, mat1_zb_sumx2);
+        acc_row1_vec0 = AE_ADD32(acc_row1_vec0, mat1_zb_sumx2);
       
         MPY_BY_QUANT_MULT_SLS_X2_OUT32(acc_row0_vec0, acc_row0_vec0, out_multiplier, left_shift, right_shift);
         MPY_BY_QUANT_MULT_SLS_X2_OUT32(acc_row1_vec0, acc_row1_vec0, out_multiplier, left_shift, right_shift);
@@ -1326,7 +1416,6 @@ WORD32 xa_nn_matXvec_asym8sxasym8s_asym8s(
     
         if(bias_flag)
         {
-          /* Load bias in the accumulator */
           AE_L32_IP(acc_row0_vec0, (ae_int32 *) p_bias, 4);
         }
     
@@ -1335,9 +1424,9 @@ WORD32 xa_nn_matXvec_asym8sxasym8s_asym8s(
            ,p_mat1_0
            ,p_vec1_0
            ,cols1
-           ,mat1_zero_bias
            ,vec1_zero_bias
           );
+        acc_row0_vec0 = AE_ADD32(acc_row0_vec0, mat1_zb_sumx2);
     
         MPY_BY_QUANT_MULT_SLS_X2_OUT32(acc_row0_vec0, acc_row0_vec0, out_multiplier, left_shift, right_shift);
         acc_row0_vec0 = AE_ADD32S(acc_row0_vec0, AE_MOVDA32(out_zero_bias));
@@ -1365,8 +1454,9 @@ WORD32 xa_nn_matXvec_asym8sxasym8s_asym8s(
         {
           /* Load bias in the accumulator */
           AE_LA32X2_IP(acc_row0_vec0, bias_valign, (ae_int32x2 *)p_bias);
-          AE_LA32X2_IP(acc_row1_vec0, bias_valign, (ae_int32x2 *)p_bias);    
+          AE_LA32X2_IP(acc_row1_vec0, bias_valign, (ae_int32x2 *)p_bias);
         }
+
         p_mat1_0 = (const WORD8 *)(p_mat1+(m_itr * row_stride1));
         p_vec1_0 = (const WORD8 *)(p_vec1);
     
@@ -1377,9 +1467,10 @@ WORD32 xa_nn_matXvec_asym8sxasym8s_asym8s(
            ,p_vec1_0
            ,cols1
            ,row_stride1
-           ,mat1_zero_bias
            ,vec1_zero_bias
           );
+        acc_row0_vec0 = AE_ADD32(acc_row0_vec0, mat1_zb_sumx2);
+        acc_row1_vec0 = AE_ADD32(acc_row1_vec0, mat1_zb_sumx2);
     
         MPY_BY_QUANT_MULT_SLS_X2_OUT32(acc_row0_vec0, acc_row0_vec0, out_multiplier, left_shift, right_shift);
         MPY_BY_QUANT_MULT_SLS_X2_OUT32(acc_row1_vec0, acc_row1_vec0, out_multiplier, left_shift, right_shift);
@@ -1429,7 +1520,7 @@ WORD32 xa_nn_matXvec_asym8sxasym8s_asym8s(
         {
           /* Load bias in the accumulator */
           AE_LA32X2_IP(acc_row0_vec0, bias_valign, (ae_int32x2 *)p_bias);
-          AE_LA32X2_IP(acc_row1_vec0, bias_valign, (ae_int32x2 *)p_bias);  
+          AE_LA32X2_IP(acc_row1_vec0, bias_valign, (ae_int32x2 *)p_bias);
         }
     
         _xa_nn_dot_product_4_rows_1_vecs_offset_aligned
@@ -1439,9 +1530,10 @@ WORD32 xa_nn_matXvec_asym8sxasym8s_asym8s(
            ,(WORD8*)p_vec1_0
            ,cols1
            ,row_stride1
-           ,mat1_zero_bias
            ,vec1_zero_bias
           );
+        acc_row0_vec0 = AE_ADD32(acc_row0_vec0, mat1_zb_sumx2);
+        acc_row1_vec0 = AE_ADD32(acc_row1_vec0, mat1_zb_sumx2);
     
         MPY_BY_QUANT_MULT_SLS_X2_OUT32(acc_row0_vec0, acc_row0_vec0, out_multiplier, left_shift, right_shift);
         MPY_BY_QUANT_MULT_SLS_X2_OUT32(acc_row1_vec0, acc_row1_vec0, out_multiplier, left_shift, right_shift);
@@ -1477,7 +1569,6 @@ WORD32 xa_nn_matXvec_asym8sxasym8s_asym8s(
     
         if(bias_flag)
         {
-          /* Load bias in the accumulator */
           AE_L32_IP(acc_row0_vec0, (ae_int32 *) p_bias, 4);
         }
     
@@ -1486,9 +1577,9 @@ WORD32 xa_nn_matXvec_asym8sxasym8s_asym8s(
            ,p_mat1_0
            ,p_vec1_0
            ,cols1
-           ,mat1_zero_bias
            ,vec1_zero_bias
           );
+        acc_row0_vec0 = AE_ADD32(acc_row0_vec0, mat1_zb_sumx2);
     
         MPY_BY_QUANT_MULT_SLS_X2_OUT32(acc_row0_vec0, acc_row0_vec0, out_multiplier, left_shift, right_shift);
         acc_row0_vec0 = AE_ADD32S(acc_row0_vec0, AE_MOVDA32(out_zero_bias));
diff --git a/include/nnlib/xa_nnlib_kernels_api.h b/include/nnlib/xa_nnlib_kernels_api.h
index e0cc344..d540aac 100644
--- a/include/nnlib/xa_nnlib_kernels_api.h
+++ b/include/nnlib/xa_nnlib_kernels_api.h
@@ -790,6 +790,22 @@
       WORD32 kernel_precision,
       WORD32 output_precision);
 
+	WORD32 xa_nn_transpose_conv_sym8sxasym8s(
+			WORD8* output_data,
+			const WORD8* input_data,
+			const WORD8* filter_data,
+			const WORD32* bias_data,
+			int stride_width, int stride_height,
+			int pad_width, int pad_height,
+			int input_depth, int output_depth,
+			int input_height, int input_width,
+			int filter_height, int filter_width,
+			int output_height, int output_width,
+			int num_elements,
+      int input_offset, int output_offset,
+			int *output_shift, int *output_multiplier,
+			WORD32* scratch_buffer);
+
 	WORD32 xa_nn_transpose_conv_sym8sxsym16s(
 			WORD16* output_data,
 			const WORD16* input_data,
@@ -2293,6 +2309,22 @@
             WORD32  inp2_multiplier,
             WORD32  left_shift);
 
+    WORD32 xa_nn_elm_squared_diff_broadcast_4D_sym16sxsym16s_sym16s(WORD16 * __restrict__ p_out,
+            const WORD32 *const p_out_shape,
+            WORD32  out_left_shift,
+            WORD32  out_multiplier,
+            WORD32  out_activation_min,
+            WORD32  out_activation_max,
+            const WORD16 * __restrict__ p_inp1,
+            const WORD32 *const p_inp1_shape,
+            WORD32  inp1_left_shift,
+            WORD32  inp1_multiplier,
+            const WORD16 * __restrict__ p_inp2,
+            const WORD32 *const p_inp2_shape,
+            WORD32  inp2_left_shift,
+            WORD32  inp2_multiplier,
+            WORD32  left_shift);
+
     WORD32 xa_nn_lstm_cell_state_update_16(WORD16* p_cell_state,
             const WORD16* p_forget_gate,
             const WORD16* p_cell_gate,
@@ -2529,6 +2561,30 @@
 			,WORD32 out_zero_bias
 			,pVOID p_scratch_in);
 
+	WORD32 xa_nn_reduce_max_4D_asym16s_asym16s(WORD16 * __restrict__ p_out
+			,const WORD32 *const p_out_shape
+			,const WORD16 * __restrict__ p_inp
+			,const WORD32 *const p_inp_shape
+			,const WORD32 * __restrict__ p_axis
+			,WORD32 num_out_dims
+			,WORD32 num_inp_dims
+			,WORD32 num_axis_dims
+			,pVOID p_scratch_in);
+
+	WORD32 xa_nn_reduce_mean_4D_asym16s_asym16s(WORD16 * __restrict__ p_out
+			,const WORD32 *const p_out_shape
+			,const WORD16 * __restrict__ p_inp
+			,const WORD32 *const p_inp_shape
+			,const WORD32 * __restrict__ p_axis
+			,WORD32 num_out_dims
+			,WORD32 num_inp_dims
+			,WORD32 num_axis_dims
+			,WORD32 inp_zero_bias
+			,WORD32 out_multiplier
+			,WORD32 out_shift
+			,WORD32 out_zero_bias
+			,pVOID p_scratch_in);
+
 	WORD32 xa_nn_elm_logicaland_boolxbool_bool(WORD8 * __restrict__ p_out,
 			const   WORD8 * __restrict__ p_inp1,
 			const   WORD8 * __restrict__ p_inp2,
