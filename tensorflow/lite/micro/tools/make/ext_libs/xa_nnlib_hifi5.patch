diff --git a/algo/kernels/cnn/hifi5/xa_nn_conv2d_std_circ_buf.c b/algo/kernels/cnn/hifi5/xa_nn_conv2d_std_circ_buf.c
index e906da4c..ede58924 100644
--- a/algo/kernels/cnn/hifi5/xa_nn_conv2d_std_circ_buf.c
+++ b/algo/kernels/cnn/hifi5/xa_nn_conv2d_std_circ_buf.c
@@ -1923,5 +1923,30 @@ VOID conv2d_std_update_cir_buf_asym8(
   /* Skip required number of input frames */
   p_inp += to_skip_inp_width * input_channels;
   *pp_inp = (VOID *)p_inp;
+}
 
+WORD32 xa_nn_streaming_conv_init_state(
+    VOID *p_mem,
+    VOID *p_kernel,
+    WORD32 input_height,
+    WORD32 input_channels,
+    WORD32 kernel_height,
+    WORD32 kernel_width,
+    WORD32 x_stride,
+    WORD32 y_stride,
+    WORD32 y_padding,
+    WORD32 out_height,
+    WORD32 output_channels,
+    WORD32 input_precision,
+    WORD32 kernel_precision,
+    WORD32 pad_val)
+{
+  (void)output_channels; (void)kernel_precision;
+  xa_nn_conv2d_std_init_state(p_mem, p_kernel, input_height, input_channels, kernel_height, kernel_width,
+                              x_stride, y_stride, y_padding, out_height, input_precision);
+  WORD8 *pbegin = AE_GETCBEGIN0();
+  WORD8 *pend  = AE_GETCEND0();
+  UWORD8 padval8 = (UWORD8)pad_val;
+  memset(pbegin, padval8, (unsigned int)(pend-pbegin));
+  return 0;
 }
diff --git a/algo/kernels/cnn/hifi5/xa_nn_conv2d_std_sym8sxsym16s.c b/algo/kernels/cnn/hifi5/xa_nn_conv2d_std_sym8sxsym16s.c
index 8000e965..c06777f3 100644
--- a/algo/kernels/cnn/hifi5/xa_nn_conv2d_std_sym8sxsym16s.c
+++ b/algo/kernels/cnn/hifi5/xa_nn_conv2d_std_sym8sxsym16s.c
@@ -276,3 +276,100 @@ WORD32 xa_nn_conv2d_std_per_chan_sym8sxsym16s(
 
   return 0;
 }
+
+/* Streaming Conv
+ * I/O widths are 1
+ * Incoming layer gets updated in circular buffer, which is used to compute one output width layer
+ */
+WORD32 xa_nn_streaming_conv_sym8sxsym16s(
+    WORD16* __restrict__ p_out,
+    const WORD16* __restrict__ p_inp,
+    const WORD8* __restrict__ p_kernel,
+    const WORD64* __restrict__ p_bias,
+    WORD32 input_height,
+    WORD32 input_width,
+    WORD32 input_channels,
+    WORD32 kernel_height,
+    WORD32 kernel_width,
+    WORD32 out_channels,
+    WORD32 x_stride,
+    WORD32 y_stride,
+    WORD32 x_padding,
+    WORD32 y_padding,
+    WORD32 out_height,
+    WORD32 out_width,
+    WORD32 input_zero_bias,
+    WORD32 * p_out_multiplier,
+    WORD32 * p_out_shift,
+    WORD32 out_zero_bias,
+    WORD32 out_data_format,
+    VOID *p_state_ptr
+    ) /* likely not required, p_state_ptr should contain all the info needed */
+{
+   /* NULL pointer checks */
+  XA_NNLIB_ARG_CHK_PTR(p_out, -1);
+  XA_NNLIB_ARG_CHK_PTR(p_kernel, -1);
+  XA_NNLIB_ARG_CHK_PTR(p_inp, -1);
+  XA_NNLIB_ARG_CHK_PTR(p_bias, -1);
+  /* Pointer alignment checks */
+  XA_NNLIB_ARG_CHK_ALIGN(p_bias, sizeof(WORD64), -1);
+  /* Basic Parameter checks */
+  XA_NNLIB_ARG_CHK_COND((input_height <= 0 || input_width <= 0), -1);
+  XA_NNLIB_ARG_CHK_COND((input_channels <= 0), -1);
+  XA_NNLIB_ARG_CHK_COND((kernel_height <= 0 || kernel_width <= 0), -1);
+  XA_NNLIB_ARG_CHK_COND((out_channels <= 0), -1);
+  XA_NNLIB_ARG_CHK_COND((y_stride <= 0 || x_stride <= 0), -1);
+  XA_NNLIB_ARG_CHK_COND((y_padding < 0 || x_padding < 0), -1);
+  XA_NNLIB_ARG_CHK_COND((out_height <= 0 || out_width <= 0), -1);
+  XA_NNLIB_ARG_CHK_COND((input_zero_bias != 0), -1);
+  XA_NNLIB_ARG_CHK_COND((out_zero_bias != 0), -1);
+  XA_NNLIB_ARG_CHK_COND((out_data_format != 0 && out_data_format != 1), -1);
+  // Specific for streaming conv
+  XA_NNLIB_ARG_CHK_COND((input_width != 1), -1);
+  XA_NNLIB_ARG_CHK_COND((out_width != 1), -1);
+  XA_NNLIB_ARG_CHK_COND((x_padding != 0), -1);
+  XA_NNLIB_ARG_CHK_COND((x_stride != 1), -1);
+
+  int itr;
+  for(itr=0;itr<out_channels;itr++){
+    XA_NNLIB_ARG_CHK_COND((p_out_shift[itr] < -31 || p_out_shift[itr] > 31), -1);
+  }
+
+  WORD32 j;
+  WORD32 input_bytewidth = 2;
+  VOID *pp_inp = (VOID *)p_inp;
+
+  xa_nn_conv_state_t *p_state = (xa_nn_conv_state_t *)p_state_ptr;
+
+  WORD32 out_channels_offset = out_data_format ? out_height * out_width : 1;
+  WORD32 out_height_offset = out_data_format ? out_width : out_width * out_channels;
+  WORD32 out_width_offset = out_data_format ? 1 : out_channels;
+
+  WORD32 input_channels_pad = input_channels;
+
+  WORD32 y_b_pad = kernel_height + (out_height - 1) * y_stride - (y_padding + input_height);
+  y_b_pad = y_b_pad < 0 ? 0 : y_b_pad;
+
+  // Add x_stride x (input_height x input_channels) new planes to circular buffer
+  conv2d_std_update_cir_buf(input_channels, input_channels_pad, input_bytewidth, input_width, input_height, y_padding, y_b_pad, 0, kernel_width, x_stride, (VOID**)&pp_inp, 0, p_state);
+
+  // Convolution using matXvec with matrix as circular buffer
+    xa_nn_matXvec_sym8sxsym16s_sym16s_circ
+      (p_out /* output */
+       ,p_state->cir_buf.p_curr/* matrix: rows x cols */
+       ,p_kernel /* vec: cols */
+       ,p_bias /* bias */
+       ,out_height /* rows */
+       ,input_channels_pad * kernel_width * kernel_height /* cols */
+       ,input_channels_pad * kernel_width * y_stride/* row_offset */
+       ,out_channels /* vec_count */
+       ,input_channels_pad * kernel_width * kernel_height /* vec_stride */
+       ,out_channels_offset /* out_col_offset */
+       ,out_height_offset /* out_row_offset */
+       ,input_zero_bias
+       ,p_out_multiplier
+       ,p_out_shift
+       ,out_zero_bias
+      );
+  return 0;
+}
diff --git a/include/nnlib/xa_nnlib_kernels_api.h b/include/nnlib/xa_nnlib_kernels_api.h
index a8830757..431b6329 100644
--- a/include/nnlib/xa_nnlib_kernels_api.h
+++ b/include/nnlib/xa_nnlib_kernels_api.h
@@ -1863,6 +1863,47 @@
 			WORD32 out_data_format,
 			VOID *p_scratch);
 
+         WORD32 xa_nn_streaming_conv_init_state(
+                        VOID *p_scratch,
+                        VOID *p_kernel,
+                        WORD32 input_height,
+                        WORD32 input_channels,
+                        WORD32 kernel_height,
+                        WORD32 kernel_width,
+                        WORD32 x_stride,
+                        WORD32 y_stride,
+                        WORD32 y_padding,
+                        WORD32 out_height,
+                        WORD32 output_channels,
+                        WORD32 input_precision,
+                        WORD32 kernel_precision,
+                        WORD32 padval);
+
+	WORD32 xa_nn_streaming_conv_sym8sxsym16s(
+			WORD16* __restrict__ p_out,
+			const WORD16* __restrict__ p_inp,
+			const WORD8* __restrict__ p_kernel,
+			const WORD64* __restrict__ p_bias,
+			WORD32 input_height,
+			WORD32 input_width,
+			WORD32 input_channels,
+			WORD32 kernel_height,
+			WORD32 kernel_width,
+			WORD32 out_channels,
+			WORD32 x_stride,
+			WORD32 y_stride,
+			WORD32 x_padding,
+			WORD32 y_padding,
+			WORD32 out_height,
+			WORD32 out_width,
+			WORD32 input_zero_bias,
+			WORD32 * p_out_multiplier,
+			WORD32 * p_out_shift,
+			WORD32 out_zero_bias,
+			WORD32 out_data_format,
+                        VOID *p_state
+			);
+
 	WORD32 xa_nn_conv2d_std_per_chan_sym8sxasym8s(
 			WORD8* __restrict__ p_out,
 			const WORD8* __restrict__ p_inp,
